Start: 23April2024

https://www.youtube.com/watch?v=5199E50O7SI&ab_channel=freeCodeCamp.org
https://graphql.org/
Course Github(Each Lesson has it's own branch, click on the branch dropdown to select - can download a zip folder / or clone repo):
https://github.com/iamshaunjp/graphql-crash-course
Apollo Explorer = Free Tool for testing different kinds of queries(not steppoop-Thank God)
https://www.apollographql.com/docs/graphos/explorer/

GraphQL = Query Language for your API, with a server-side run time for executing queries, using a type system you define for your data, GraphQL isn't tied to any specific database or storage engine
GraphQL creates a uniform API across your entire application without being limited by a specific storage engine. Write GraphQL APIs that leverage your existing data and code with GraphQL engines available in many languages.
GraphQL = Query Language, a specific syntax to query a server to request or mutate data, instead of a REST API using endpoints - Architectual Style - http requests - REST API's don't scale well, or with complex data
  Actual Language with it's own syntax/language - allows you to select what data you want to query - 
OverFetching = Getting more data than we need
UnderFetching = Getting less data than we need - you would need to make a different request to an additional endpoint to get the data you need - each method GET POST REQUEST DELETE ETC, would typically have it's own endpoint
With GraphQL we use a single endpoint - The syntax allows us to specify exactly what data and what fields we need back from the server, also allows us to fetch nested related data in a single query
Query {
  courses {
    id,
    title,
    thumbnail_url
  }
} # would specify that we want the 'courses' resource, and we want to return the 'id' 'title' and 'thumbnail_url' only

Query {
  course(id: "1") {
  id,
  title,
  thumbnail_url,
  author {
    name,
    id,
    courses {
      id,
      title,
      thumbnail_url
    }
  }
} # example query where we specify to query the course with id of '1' and returns nested results for 'author' and 'courses' done by him and any related data with 'id' 'title' 'thumbnail_url'
When you scale up an app, the data layer becomes much more complex, 
Mutations = You can ask the GraphQL Server to update data/Delete Data/Create data, similar to a PUSH request, but on a single endpoint

10:00==================================================================================================================================================================================================================================
We are going to create a GraphQL Server using NodeJS and apollo server, responsible for handling all the queries and mutations, to send the queries we will use apollo explorer
Apollo Sandbox:
https://www.apollographql.com/docs/graphos/explorer/sandbox/
When you open the sandbox, it connects to a dummy GraphQL server, so you don't have to make an account(Cough-Steppoop) to practice and play around with it. 
A GraphQL server can expose multiple different resources to the client, You can specify which resources you want to use as entry points in the query, and what data you want to fetch from that resource: query QueryName{resource{data}}
If you want to specify which resource you want to pull from use (): Query{ game(id: "2"){title}} #will query the game with with id of 2 for it's title
Here is an example of a nested Query: Query { game(id: "2") {title, review { rating, author {name} }, } # will get the game with id of 2 , with title, review rating with the author name in a nested query, different resources 1 query
Apollo Sandbox also allows us to practice Mutations for 'AddMutation' 'DeleteMutation' and 'UpdateMutation'

Lesson 3=20:00==========================================================================================================================================================================================================================
Making our very own GraphQL Server on the backend: using NodeJS and Apollo Server
Apollo Server is one of many different libraries you can use to spin up a GraphQL server, the good thing about Apollo Server is it automatically spins up an instance on Apollo Explorer for us on LocalHost we can use to test API
resolver functions = respond to incoming queries, also let's us easily model our different data types
'schema.js' Will allow us to dictate how every different graph is connected
Apollo Docs - Getting Started:
https://www.apollographql.com/docs/apollo-server/getting-started/

Step 1: Create a new project
From your preferred development directory, create a directory for a new project and cd into it:
mkdir graphql-server-example 
cd graphql-server-example

Step 2: Install dependencies
Initialize a new Node.js project with npm (or another package manager you prefer, such as Yarn):
npm init --yes && npm pkg set type="module" #sets up a project using ES Modules, which simplifies our examples and allows us to use top-level await.
npm install @apollo/server graphql #installs apollo server and graphql

Step 3: Define your GraphQL schema
If you're using JavaScript, use .js and .jsx file extensions wherever .ts and .tsx appear.
Every GraphQL server (including Apollo Server) uses a schema to define the structure of data that clients can query. 
const typeDefs = `#graphql
  # Comments in GraphQL strings (such as this one) start with the hash (#) symbol.

  # This "Book" type defines the queryable fields for every book in our data source.
  type Book {
    title: String
    author: String
  }

  # The "Query" type is special: it lists all of the available queries that
  # clients can execute, along with the return type for each. In this
  # case, the "books" query returns an array of zero or more Books (defined above).
  type Query {
    books: [Book]
  }
`;# This snippet defines a simple, valid GraphQL schema. Clients will be able to execute a query named books, and our server will return an array of zero or more Books.

Imports:
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

Step 4: Define your data set
Now that we've defined the structure of our data, we can define the data itself.
Apollo Server can fetch data from any source you connect to (including a database, a REST API, a static object storage service, or even another GraphQL server). 
const books = [
  {
    title: 'The Awakening',
    author: 'Kate Chopin',
  },
  {
    title: 'City of Glass',
    author: 'Paul Auster',
  },
];

Step 5: Define a resolver
// Resolvers define how to fetch the types defined in your schema.
// This resolver retrieves books from the "books" array above.
const resolvers = {
  Query: {
    books: () => books,
  },
};

Step 6: Create an instance of ApolloServer
We've defined our schema, data set, and resolver. Now we need to provide this information to Apollo Server when we initialize it.
Add the following to the bottom of your index.ts file:
// The ApolloServer constructor requires two parameters: your schema
// definition and your set of resolvers.
const server = new ApolloServer({
  typeDefs,
  resolvers,
});
// Passing an ApolloServer instance to the `startStandaloneServer` function:
//  1. creates an Express app
//  2. installs your ApolloServer instance as middleware
//  3. prepares your app to handle incoming requests
const { url } = await startStandaloneServer(server, {
  listen: { port: 4000 },
});
console.log(`ðŸš€  Server ready at: ${url}`);

Step 7: Start the server
npm start

Step 8: Execute your first query
We can now execute GraphQL queries on our server. To execute our first query, we can use Apollo Sandbox.
Visit http://localhost:4000 in your browser, which will open the Apollo Sandbox:

26:00=Lesson 4: Schema and Types======================================================================================================================================================================================================
type Defs = Definitions of the different types you want to express on your graph and specify the different fields(data) that each resource might have = All of this combined will be called the 'schema'
Installed 'GraphQL: Syntax Highlighting' extension in VSCode for highlighting each different type in a different color
export const typeDefs = `#graphql #`` backticks are 'template strings'
Built into GraphQL there are 5 different types: int / floats / strings / boolean / ID(key-serialized strings-unique type in GraphQL)
You can create your own types in GraphQL(unlikely you will ever do this, but you can.)
[] = you can say that something is going to be an array of something with []'s 'platform: [String]' = it will be an array of strings
! = you can make a field required by adding on an exclamation mark 'title: String!', if you don' thave ! it can be nullable, you will need 2 ! for an array 'platform: [String!]!' = non nullable array of strings
type Query {} #Every single GraphQL schema requires this, it is not optional, it's job is to define the entry points to the graph and specify the return types of those entry points, a way of gatekeeping entry on the graph
type Query {
  reviews: [Reviews] #will return a list of reviews
  games: [Game] #will return a list of game objects
}
export const tpesDefs #always make sure that your typeDefs are exported, so you can use your schema and import it in other files
import { typeDefs } from './schema.js'

36:30=Lesson 5: Resolver Functions=====================================================================================================================================================================================================
resolvers = a function that handles any incoming request and returns data to the client









































