Start : 16October2024

Tut will have us set up a NodeJS and Express App inside a docker container with a MongoDB and Redis
npm init -y #will create a 'package.json' in your cwd
npm install express #will install express, add it to 'package.json' 'package-lock.json'
create a 'index.js'
const express = require("express"); #imports express
const app = express();
app.get("/", (req, res) => {res.send("<h1>Test Success</h2>");}); #quick route for testing purposes, "/" from route path, will send back the response as an h2 element 'Test Success'
const port = process.env.PORT || 3000; #will set the port to the environment variable, or default to 3000
app.listen(port, () => console.log(`listening on port${port}`)); #when appconnects to a port will print out which port it is on
#above is the simplest express app you can build
'node index.js' #in the terminal, will run the above script on 'localhost:3000'

Docker: 
Install Docker on Arch Linux: 
https://docs.docker.com/desktop/install/linux/archlinux/
https://wiki.archlinux.org/title/Docker
-Couldn't install docker-desktop, did a 'sudo pacman -Syu' and going to reboot, system update and reboot worked, now have docker desktop installed on Arch linux(btw.)
https://hub.docker.com/ #where images are saved
https://hub.docker.com/_/node #official node docker image, a lightweight img with node already installed, you can select which version you want
The image above doesn't have everything we want, the idea(l) of an image is that it has everything in it for your application to work, so you will need:
Source code(Application)/Dependancies/etc
So we are going to create our own custom image based on that node image, I need to fix my '.gitignore' file so I'm not uploading the docker image to github
Take that node image, copy our source code into that node image, then install all dependancies, then build that final image that has everything we need to run the app
To create a custom image, you need to create a 'Dockerfile' which is just a set of instructions that docker is going to run to create a custom image
  It will run a set of commands the create the docker image :
The first command you will always have to do is specify a base image, it can be a known image you own, or hub.docker.com image, anywhere
'FROM node:15' #will take the 'node' image from docker hub the ':15' specifies the version number (15 here) default is ':latest'
'WORKDIR /app' #notice how all commands are in caps, this will set the working directory to be the '/app' directory within the container
  After setting the work directory, any time you run a command, it's going to run that command from that directory, so put all the application code in /app, then run 'index.js' on '/app' and it will run
'COPY package.json .' #'package.json' contains all dependancies, will copy it into the '.' is a relative directory it means our current directory which we set above with 'WORKDIR'(/app)
'RUN npm install' #will run a command from the working directory, since we copied the 'package.json' it will install all dependancies
'COPY . ./' #will copy all remaining files from folder into the working directory, optimization technique, to add this after the package.json - has to do with layering and builds, wrote about it below
Each command we ran above creates another layer, since docker is efficient, it will know that nothing has changed, and will rebuild only the layers that have changes when you 'docker build'
  so you won't need to run 'npm install' after each docker build because you seperated the layers above with the 2 COPY statements, if you change your code you will just rebuild the fifth layer'COPY . ./'
'EXPOSE 3000' #our app will be running on port 3000
'CMD ["node", "index.js"]' #will run 'node index.js' from terminal after being deployed in container at runtime

'docker build .' #from the terminal '.' is context for current working directory, which we are already in, we have named our 'Dockerfile' and it worked, even with old node version(15, current is 24?) cool
1/5: Grabs image from docker hub - 2/5 Sets working dir - 3/5 Copies package.json - 4/5 runs npm install - 5/5 copies remaining files - caches each result, so next time you run will be quicker
'docker image ls' #we forgot to name our image above, so it is labeled <NONE>, but still has an IMAGE ID
'docker image rm <IMAGE ID>' #will remove the docker image with the ID 
'docker build -t node-app-image .' #will create a new image with the '-t' flag will allow us to name it, '.' is context for current working directory 
'docker run node-app-image' #will run our newly created image
'docker run -d --name node-app node-app-image' #will run custom image, but with '-d' flag which is detached mode(will allow you to use CLI), and '--name' flag which will name it 'node-app'
'docker ps' will list all containers currently running at the moment

Container is running, but page won't load, to fix this you need to :
'EXPOSE 3000' #port is exposed, allegedly, this doesn't work though, it's a comment for the dockerfile to let other people know that the image expects others to open port 3000 to work, it doesn't actually do it
by default, as a security feature, docker does not allow anything from outside to communicate with it, it can communicate to the outside but no outside in
to change this, you need to tell the host machine if you receive traffic from a specific port - you want to forward that traffic to the docker container
'docker rm node-app -f' #will remove the current running container we just created, '-f' flag like other programs is force, normally you need to stop a container before you delete it, it won't delete image
'docker run -p 3000:3000 -d --name node-app node-app-image' #same command as above, but this time '-p' flag '3000:3000' 
  left:right- right number on the right is where traffic is sent on container(app is listening to 3000)
  left: represents traffic coming in from outside, so if another device on network/localhost is sending traffic to localhost:3000, it will send it to port 3000 on container















