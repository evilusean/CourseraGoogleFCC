Features:
Completely dynamic product loading - products are not hardcoded, and will load chronologically
pagination - fast page loading - pre rendered and cached
cart - with total cost, subtotal, and quantity, server action nextJS feature, POST request
anonymous shopping cart - if you log out of account, new shopping cart will be created, and you can add items to it, and merge when you log back in
authentication - can log into accounts
checkout button is a dummy 
server side rendering - good for SEO(search engine optimization) - all data available when you open webpage
search functionality 
responsive design - changes based on screen size
tailwind css
Cookies - will store cart details and authentication 


npx create-next-app@latest
typescript: yes / eslint: yes / ESLint: yes / TailwindCSS: yes / src/directory: yes / AppRouter: yes / import alias: no
'npm run dev' to test if setup was successful localhost:3000

Installing prerequisite packages:
npm i daisyui prisma @prisma/client next-auth @auth/prisma-adapter prettier eslint-config-prettier prettier-plugin-tailwindcss

Setting up TailwindCSS:
https://tailwindcss.com/docs/installation
https://tailwindcss.com/docs/editor-setup
VSCode Extensions:
Tailwind CSS IntelliSense
Reccomended VS Code Settings:
'files.associations' settings to always open .css files in Tailwind CSS mode; top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'files: association' -> add item -> items: *.css Value: tailwind.css
  #after doing above, tailwindcss will now work in .css files (no more yellow warnings for the entire project!)
"files.associations":  {
  "*.css: "tailwindcss"
  }
'editor.quickSuggestions' =   top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'editor.quickSuggestions' -> add item -> strings: on
#by default VScode will not trigger completions when editing string content, updating the 'editor.quickSuggestions' settings may improve your experience, autosuggestions in strings
"editor.quickSuggestions': {
  "strings": true
}

20:00===============================================================================================================================================================================================================================
Daisy UI Configuration:
https://daisyui.com/docs/install/
DaisyUI is a components libarary, that has components prebuilt that are already configured, buttons, modal dialogues, progress bar, custom themes, theme generator - copy paste into tailwind file
https://daisyui.com/theme-generator/
Cool random generator for color palletes, or you can use a prebuilt like synthwave, I went with what was recomended
'tailwindconfig.js' #add below code to it, delete 'theme:' block
module.exports = {
  //...
  plugins: [require("daisyui")],
}
instead of hardcoding, if you set up a theme, you can change it all at once from one file, good to set up before you start coding, going with default for now wasted too much time fiddling around with palletes
after DaisyUI import, deleted everything from 'globals.css', except lines at top @tailwind
next, we need to import our automatic class ordering with tailwindcss and prettier, we already installed, but need to add to plugin to our prettier config
https://github.com/tailwindlabs/prettier-plugin-tailwindcss
npm install -D prettier prettier-plugin-tailwindcss
go into 'root' folder and create a new file called 'prettier.config.js' and added below code
module.exports = {
    plugins: ['prettier-plugin-tailwindcss'],
  } 
installed 'prettier - code formatter' extension
to make default for editing: top drop down File -> Preferences -> Settings - Change from 'none' to 'Prettier'

Error: Fixed:
Create file called .babelrc in your root directory and add this code:
{
  "presets": ["next/babel"],
  "plugins": []
}
And in .eslintrc, replace the existing code with:

{
  "extends": ["next/babel","next/core-web-vitals"]
}

For Future Sean: Prettier and ESlint can conflict, that's why you need to do the above fix every time you use it,
https://nextjs.org/docs/app/building-your-application/configuring/eslint#prettier
Installed ESLint extension aswell,
Next installed 'Prisma' extension, an ORM , it works with our MongoDB, will help us set up our schema file and gives us autocompletion, and helps with formatting
npm i zod #final package we need to install for our project,

27:00===============================================================================================================================================================================================================================
opengraph-image.png #downloaded for tut, the file needs that exact name and MUST be in src / app folder, it is used for the display image on pages like facebook
Now it's time to set up MongoDB:
https://www.mongodb.com/atlas/database
we already have an account from our last project, top left drop down -> New Project - NextJS-E-Commerce
MongoDB is good because they take care of a lot of things you would otherwise need to set up for yourself, such as replicas and switches, additional backup servers
created our first DB;DB name: ecommerce / Collection Name: products
added in our first product manually, by clicking 'INSERT DOCUMENT' in top right, Dummy Data Schema Below:
_id:65f87c86d239b4b6af147de7 ObjectId
name:"Product Name" String
description: "Product Description" String
imageUrl: "https://product-image.com: String
price:999 Int32
Floats are inacurrate, so we created our price as an integer32

34:00=============================================================================================================================================================================================================================
Prisma(what we are using to work with our DB):
https://www.prisma.io/
'npx prisma init' #will initialize prisma, creates a .env file with database URL placeholder, replace that string with the connect string from MongoDB
'npx prisma db pull' #we can tell prisma to pull the dummy data we added to our collection and add a schema from that data, so we don't have to set it up ourselves.
introspection = infers the db from the data you already have input in the DB
createdAt DateTime @default(now()) #creates a timestamp when data is created
@@map("products") #will map our model with a different name(Product) to the ecommerce.products of our DB
'npx prisma db push' #changes will be applied to our MongoDB from our schema code
'npx prisma generate' #will generate a prisma client, which you can use to call different DB operations on, whenever you make changes to schema, you need to regenerate your prisma client
  import { PrismaClient } from '@prisma/client'
  const prisma = new PrismaClient()
Getting Prisma to work with NextJS:
https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices

45:00==============================================================================================================================================================================================================================
After introspecting our schema, we can now delete our dummy data
'npm run dev' #time to start building
created a new folder in src / app / add-product 'page.tsx' routing will load this automatically, we can navigate to it through localhost:3000/add-product
Error: Fixed = had to delete babl.rc and remove next/babel from config file, was causing a problem
Error: Our Tailwind classes are not working Fixed: added below code to 'tailwind.config.js'
/** @type {import('tailwindcss').Config} */

48:00==============================================================================================================================================================================================================================
className = "" #used by tailwind to style different elements and components
we get autocompletion with our tailwind VSCode extension, you can hover over the individual items in className to see what each one does with detail
'Shift' + 'Alt' + F = shortcut to reorder all classes in correct order(windows only, doesn't work on linux)
Daisy UI components:
https://daisyui.com/components/input/
What daisy UI does is it already has pre-styled all tailwindCSS components, so you don't need to do it manually, you can search for whatever component you need above, and hover over to see tailwindCSS inputs in VSCode
<input className="mb-3 w-full input input-bordered" /> #will create a rounded box input with predesigned tailwindCSS from daisyUI with custom classNames we searched up
'layout.tsx' is the root layout, where all styling will be applied to every page in your app, which returns your components/pages as children 
<main className="p-4 max-w-7xl m-auto min-w-[300px]"> #created a new main tag that will apply styling of padding and max-width/min width[with a custom value] and auto-margin center to all of our pages

60:00==============================================================================================================================================================================================================================
export const metadata = {
    title: "Add Product"
} #overrides the default metadata in our 'layout.tsx' file, will change the title but only for the page where we put the 'export const metadata'
when we submit the form, we want to store a new product in our database, 1) turn it into a client component so we can execute JS, 2)take input of form and send by a fetch to server endpoint and add a product to a DB
  you can't make server operations on the client, because it exposes the DB credentials on the client, why you must route connections like this over a server 
NextJS Server Actions:
https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
Next JS server actions will allow you to a way to do server mutation directly through components without having to set up a server endpoint, just put a function inside of component and you can alter DB
Error : Cannot find name 'redirect'.
https://nextjs.org/docs/app/building-your-application/routing/redirecting

1:12:00============================================================================================================================================================================================================================
You can also use react hooks for validation, but need to make it a client component to use JS actions
Later in tutorial, we are going to protect the route 'page.tsx' add product page by making it so you can only add a product if you are logged in with the right credentials, after we add authentication
Where to get our images for products(free):
https://unsplash.com/
search product images, click, 'copy image address' and paste into our add-product page ImageUrl
You can use chatGPT to write product descriptions instead of mentally vomiting over the product or whatever below is:
In the diablo immortal words of blizzard entertainment; Do you guys not have a phone? Is that 2012 calling?  With this retro Kamera-9001 every day is now 2012, 
  you can now be pretend pretentious(all the cool kids now have apple vision pro XL magnum) and the I like to watch 'Kamera Guy' tfw no OF GF. It will only cost you 6,000$(2012 money, now 15,000$), 
  it only has one lens-so 2012- so retro - RIP Kony
In our DB 15000 isn't 15000$, 150.00, 1500000 = 15,000.00 (if it doesn't make dollas it doesn't make cents)
Just Tested our First Add Product through server components without JS or an API - it works, added succesfully to MongoDB, going to use ChatGPT when uploading for the next products, saves time/mental energy
there was no loading screen when we were inputting our Data into the DB, we can create a hook, we are going to implement it into our button
import { ComponentProps } from "react";
type FormSubmitButtonProps = {
  children: React.ReactNode, #children: prop that allows us to whatever we pass in our component will be passed to the <button>THIS TEXT WILL BE PASSED HERE</button>
  className?: string, #will allow us to change the styling, className?(questionmark makes it optional) which doesn't need to be passed
} & ComponentProps<"button"> #an import from react that allows us to use all the prop(erties) from a normal <"button"> would accept, works with type, not interface

export default function FormSubmitButton(
    {children, className} : FormSubmitButtonProps #will hand our props to this function
) {
  return (
    <button type="submit">
      {children} #will be changed by the children: tag above
    </button>
  )
}

1:21:00=============================================================================================================================================================================================================================
We now have a loading button that should disable our add product submit form button component when it is sending data to the server, then redirects us to main page
the server action is treated as a post request
He added 2 more products to the DB, commented out the redirect before uploading so it didn't kick him back to main page
Created a new file called 'error.tsx' in src / app #will be the page that automatically gets shown when you have an error, naming conventions are important for this file
all 'error.tsx' components MUST be "use client";

1:30:00=============================================================================================================================================================================================================================
in src / app 'page.tsx' removed ALL boilerplate code, started with a fresh <div>
by default pages in the app directory are server components, so we can do database configs and async functions, because it will be executed on the server, not the client.. unless we say "use client"
  making DB requests and using credentials is safe, because it will not be leaked to the client, so we can use prisma here safely
export default async function Home() {
  const products = await prisma.product.findMany({
    orderBy: {id: "desc"}
  }) #will check our DB for product using the findMany function, and order them by id descending, so newest products first
in src / app / components 'ProductCard.tsx' for our product card, which will pull the data from our DB and post it on main page

1:40:00=============================================================================================================================================================================================================================
we are going to create another component in components folder called 'PriceTag.tsx'
Now we need to take our pricetag component and place it in our 'ProductCard.tsx' 
Below adds an image to our productcard, DaisyUI documentation recomends wrapping image in a figure, the image component is 'import Image from "next/image";' width and height are relative, and will change depending on screen size
      <figure>
        <Image
          src={product.imageUrl}
          alt={product.name}
          width={800}
          height={400}
          className="h-48 object-cover" #h-48 = sets the height, object-cover = center crops image
        />
      </figure>
const isNew = Date.now() - new Date(product.createdAt).getTime() <1000 * 60 * 60 * 24 * 7; #miliseconds x 60 seconds x 60 minutes x 24 hours x 7 days, if product is newer than 7 days =  true
Now we need to remove our hardcoded <ProductCard /> and make it dynamic and load in all the props we input into our DB
      <div className="hero rounded-xl bg-base-200">
        <Image 
        src={products[0].imageUrl}
        alt={products[0].name}
        width={400}
        height={800}
        className="w-full max-w-sm rounded-lg shadow-2xl"
        priority
        />
      </div> #will load our hero image, using DaisyUI Docs, it will use those className's to create our hero image, loading the [0] most recent product, the 'priority' tag will tell nextJS to load this item first

1:50:00==============================================================================================================================================================================================================================
<div className="hero-content flex-col lg:flex-row"> #how you make tailwindCSS responsive, will be flex-column(vertically) until large screens and then turn into flex-row(horizontally)
  the one without the modifier will be your default for small screens the lg: will be the modifier for large screens or larger
            <Link
              href={"/products/" + products[0].id}
              className="btn btn-primary"
            > #will create a link to the /products/[id] with id being whichever product is attached to the unique id and it's own product page
<div className="my-4 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"> #responsive grid
        {products.slice(1).map((product) => ( #map turns each product in an array to it's own product card, which we rended with our ProductCard component
          <ProductCard key={product.id} product={product} /> #renders dynamic with unique id for product_id
        ))}
      </div>

1:58:00=============================================================================================================================================================================================================================
Grid works. but need to add more products, only have 3 - will need >7ish, tedious work, will do tomo, future sean problem
the reason why you set up the<Image width={800}> is so that certain breakpoints (764pixel for large) will still have an image. even though the image is still relative based on the screen size
by default server components in react are statically cached, all products are fetched when we compile the project, even if we add new products, they will not appear
as soon as you add a search component in react JS it is automatically dynamically rendered, instead of static
next we are going to set up our src /  app  / 'products' / [id] 'page.tsx' #new file, the [] are critical for routing, page.tsx will render the product with the relevant unique id for each product
we created another file in src / app 'not-found.tsx' #will be the default page that gets loaded when a user tries to go to a page that does not exist (404), name of file is important for routing
now that we created a new 404 page, we can redirect to it dynamically, 

2:10:00=============================================================================================================================================================================================================================
Added 6 more products this morning, used chat gpt to write product descriptions, way faster.  Can test our responsive grid layout now
Metadata, in order to add metadata dynamically(product name, etc) we need to create a function, we can't do what we did before with metadata: ...
spelling is important for this function or nextJS will not recgonize it, it also must be async/promise because it needs to fetch the data from the DB
since we will be reusing this data later on in our code, we should cache it so we don't need to fetch it twice, it is done automatically if you use the 'fetch' function in JS
const getProduct = cache(async (id: string) => {
  const product = await prisma.product.findUnique({
    where: { id },
  });
  if (!product) notFound();
  return product;
});

export async function generateMetadata({
  params: { id },
}: ProductPageProps): Promise<Metadata> {
  const product = await getProduct(id);
  return {
    title: product.name,
    description: product.description,
    openGraph: {
      images: [{ url: product.imageUrl }],
    },
  };
}

Next we need to create a loading page to run while data is being fetched from our DB; src / app / 'loading.tsx' #name must be exact
Next we need to create the shopping cart in our DB and add a button, start in 'schema.prisma' file to create a new table;
we could make the changes by using dummy data in our MongoDB and then using introspection again to change the schema, but it is actually easier to modify the schema and then push the changes to our DB
model Cart {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
model CartItem {
  id        String @id @default(auto()) @map("_id") @db.ObjectId
  productId String @db.ObjectId
  quantity  Int
  cartId    String @db.ObjectId
} #added 2 models, one for our Cart, and items in the Cart

2:20:00=========================================================================================================================================================================================================================
we need to tell prisma what each id belongs to which model and they work with eachother(joins), for this we can use relations,  
  product   Product @relation(fields: [productId], references: [id]) #will add a relationship between CartItem and Product after you reformat, shortcut below
Ctrl + Shift + 'I' = Reformats code, 
  CartItem    CartItem[] #was added to Product model after we reformatted
now we need to do the same for our cart, 
cart      Cart    @relation(fields: [cartId], references: [id]) #adds a relationship between CartItem and Cart
CartItem  CartItem[] #same thing was added to our Cart model, will allow us to fetch all CartItems that belong to a particular cart, we renamed in to 'items  CartItem[]'
naming conventions are lowercase, and plural for MongoDb
@@map("carts") #will map our carts collection to our mongoDB database
@@map("cartitems") #same for our cartitems, same naming convention for our DB
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade) #what this does if we delete a product, all the card items containing it will also be deleted
'npx prisma db push' #will push all of our DB changes to our mongoDB server, created 2 new collections one for 'carts' and one for 'cartitems'
'npx prisma generate' #regenerate prisma client with new schema, remember everytime you make changes to DB to do this, so our new models will be available
Next we want to add a button to add item to our cart and a success message to let our customer know it was added succesfully
Only a client component can contain state, so we can wrap our button with the client component logic, and the rest of our page can remain a server component(more efficient)
src / app / products / [id] 'AddToCartButton.tsx'
We added a svg file, forgot to use "use client" for this component, fixed everything, looks good
now we need to add a server component for our client component, created 'actions.ts' in the same directory, we can use server actions in client components if it is in a seperate file

2:30:00=======================================================================================================================================================================================================================
src / app / lib / db 'cart.ts' #created for seperate server components to be used in a client component page
we are going to store the user in a cookie, to see if the user is logged in before we create a cart, in production this should be more secure(encrypted card.id, so user can't just modify cookies/ids)
  cookies also need additional security settings which we aren't doing in this tutorial, would also need secure settings in production
export async function createCart() {
  const newCart = await prisma.cart.create({
    data: {},
  });

  cookies().set("localCartId", newCart.id);
} #will create a cart
export async function getCart() {
  const localCartId = cookies().get("localCartId")?.value;
  const cart = localCartId
    ? await prisma.cart.findUnique({
        where: {
          id: localCartId,
        },
        include: { items: { include: { product: true } } },
      })
    : null;

  return cart;
} #will fetch a cart, if it exists, add products/items, else return null

2:40:00========================================================================================================================================================================================================================
export type CartWithProducts = Prisma.CartGetPayload<{
  include: { items: { include: { product: true } } };
}>; #will allow us to use our cart in our server components

2:50:00========================================================================================================================================================================================================================
We need to use startTransition(()) hook so if an error occurs, it will stay serverside and won't crash the page/app
const [isPending, StartTransition] = useTransition(); # how we initialize variables and naming convention, and the react hook useTransition we will be using to handle our onClick
  #useTransition takes care of handling the error and loading state properly
const [success, setSuccess] = useState(false); #used for success message and loading state with a boolean value, how it handles onClick below
<button className="btn btn-primary" onClick={() => {
        setSuccess(false);
        startTransition(async () => {
          await incrementProductQuantity(productId);
          setSuccess(true);
        }) #how we implemented the onClick handling with startTransition function, which will increment or add product, then setSuccess to (true) so we can show a success message
      </button> #placed following logic below to display success message or loading spinner after our button
      {isPending && <span className="loading loading-spinner loading-md " />}
      {!isPending && success && (
        <span className="text-success">Added to Cart!</span>
      )}

Tested our add to cart feature, works, code looks pretty rough in db though:
_id
65ff378b8a6a37cea5671cc2
productId
65fd58ee90b4cfa1d26c644a
quantity
1
cartId
65ff378a8a6a37cea5671cc1
It should also create a cookie, F12 -> Application Tab -> Cookies to test, how the real ecommerce sites do it(use cookies)
We are going to need to figure out a way to automatically delete a cart after a certain duration so we don't get too many carts stored up from AFK carts

3:00:00=========================================================================================================================================================================================================================
He deleted both cart and cartitems in DB, everything still worked, tested race conditions by double clicking, simply added a cart item and increased the quantity to 2
now it's time to add a navbar and footer so we can navigate between pages
src / app / 'Navbar' / 'Navbar.tsx'
we want our Navbar to be available for every page on our webapp so we put the <Navbar> component in the app / 'layout.tsx' 

3:10:00=========================================================================================================================================================================================================================
Added a search to the navbar, we need to use a server action to do our search, since our navbar isn't a 'use client' component, we can put the server action in the navbar directly
async function searchProducts(formData: FormData) {
    "use server";
    const searchQuery = formData.get("searchQuery")?.toString();
    if (searchQuery) {
        redirect("/search?query=" + searchQuery); 
    } #will redirect the form data to the URL+/search?query=<whatever you typed in search>
doesn't require any JS, so our search will work even without being a client side JS component, in order to maintain navbar as a server component created in app / Navbar / 'ShoppingCartButton.tsx' in order to add JS

3:21:00=========================================================================================================================================================================================================================
We added a dropdown link to our cart page, now we need to actually set up the "/cart" page
src / app / cart / 'page.tsx'

3:30:00=========================================================================================================================================================================================================================
<div className="flex flex-wrap items-center gap-3"> #flex-wrap will cause it to start a second row if it can not fit
const quantityOptions: JSX.Element[] = [];
  for (let i = 1; i <= 99; i++) {
    quantityOptions.push(
      <option value={i} key={i}>
        {i}
      </option>,
    ); #for loop to create 99 options but a switch aint one

3:40:00=========================================================================================================================================================================================================================
created new 'actions.ts' in src / app / cart / 'actions.ts' #created for logic in cart dropdown, delete add, or change, and add to prisma DB

3:50:00=========================================================================================================================================================================================================================




















