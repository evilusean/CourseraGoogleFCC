Features:
Completely dynamic product loading - products are not hardcoded, and will load chronologically
pagination - fast page loading - pre rendered and cached
cart - with total cost, subtotal, and quantity, server action nextJS feature, POST request
anonymous shopping cart - if you log out of account, new shopping cart will be created, and you can add items to it, and merge when you log back in
authentication - can log into accounts
checkout button is a dummy 
server side rendering - good for SEO(search engine optimization) - all data available when you open webpage
search functionality 
responsive design - changes based on screen size
tailwind css
Cookies - will store cart details and authentication, NextAuth will send encrypted cookie in browser of user to verify the session in database


npx create-next-app@latest
typescript: yes / eslint: yes / ESLint: yes / TailwindCSS: yes / src/directory: yes / AppRouter: yes / import alias: no
'npm run dev' to test if setup was successful localhost:3000

Installing prerequisite packages:
npm i daisyui prisma @prisma/client next-auth @auth/prisma-adapter prettier eslint-config-prettier prettier-plugin-tailwindcss

Setting up TailwindCSS:
https://tailwindcss.com/docs/installation
https://tailwindcss.com/docs/editor-setup
VSCode Extensions:
Tailwind CSS IntelliSense
Reccomended VS Code Settings:
'files.associations' settings to always open .css files in Tailwind CSS mode; top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'files: association' -> add item -> items: *.css Value: tailwind.css
  #after doing above, tailwindcss will now work in .css files (no more yellow warnings for the entire project!)
"files.associations":  {
  "*.css: "tailwindcss"
  }
'editor.quickSuggestions' =   top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'editor.quickSuggestions' -> add item -> strings: on
#by default VScode will not trigger completions when editing string content, updating the 'editor.quickSuggestions' settings may improve your experience, autosuggestions in strings
"editor.quickSuggestions': {
  "strings": true
}

20:00===============================================================================================================================================================================================================================
Daisy UI Configuration:
https://daisyui.com/docs/install/
DaisyUI is a components libarary, that has components prebuilt that are already configured, buttons, modal dialogues, progress bar, custom themes, theme generator - copy paste into tailwind file
https://daisyui.com/theme-generator/
Cool random generator for color palletes, or you can use a prebuilt like synthwave, I went with what was recomended
'tailwindconfig.js' #add below code to it, delete 'theme:' block
module.exports = {
  //...
  plugins: [require("daisyui")],
}
instead of hardcoding, if you set up a theme, you can change it all at once from one file, good to set up before you start coding, going with default for now wasted too much time fiddling around with palletes
after DaisyUI import, deleted everything from 'globals.css', except lines at top @tailwind
next, we need to import our automatic class ordering with tailwindcss and prettier, we already installed, but need to add to plugin to our prettier config
https://github.com/tailwindlabs/prettier-plugin-tailwindcss
npm install -D prettier prettier-plugin-tailwindcss
go into 'root' folder and create a new file called 'prettier.config.js' and added below code
module.exports = {
    plugins: ['prettier-plugin-tailwindcss'],
  } 
installed 'prettier - code formatter' extension
to make default for editing: top drop down File -> Preferences -> Settings - Change from 'none' to 'Prettier'

Error: Fixed:
Create file called .babelrc in your root directory and add this code:
{
  "presets": ["next/babel"],
  "plugins": []
}
And in .eslintrc, replace the existing code with:

{
  "extends": ["next/babel","next/core-web-vitals"]
}

For Future Sean: Prettier and ESlint can conflict, that's why you need to do the above fix every time you use it,
https://nextjs.org/docs/app/building-your-application/configuring/eslint#prettier
Installed ESLint extension aswell,
Next installed 'Prisma' extension, an ORM , it works with our MongoDB, will help us set up our schema file and gives us autocompletion, and helps with formatting
npm i zod #final package we need to install for our project,

27:00===============================================================================================================================================================================================================================
opengraph-image.png #downloaded for tut, the file needs that exact name and MUST be in src / app folder, it is used for the display image on pages like facebook
Now it's time to set up MongoDB:
https://www.mongodb.com/atlas/database
we already have an account from our last project, top left drop down -> New Project - NextJS-E-Commerce
MongoDB is good because they take care of a lot of things you would otherwise need to set up for yourself, such as replicas and switches, additional backup servers
created our first DB;DB name: ecommerce / Collection Name: products
added in our first product manually, by clicking 'INSERT DOCUMENT' in top right, Dummy Data Schema Below:
_id:65f87c86d239b4b6af147de7 ObjectId
name:"Product Name" String
description: "Product Description" String
imageUrl: "https://product-image.com: String
price:999 Int32
Floats are inacurrate, so we created our price as an integer32

34:00=============================================================================================================================================================================================================================
Prisma(what we are using to work with our DB):
https://www.prisma.io/
'npx prisma init' #will initialize prisma, creates a .env file with database URL placeholder, replace that string with the connect string from MongoDB
'npx prisma db pull' #we can tell prisma to pull the dummy data we added to our collection and add a schema from that data, so we don't have to set it up ourselves.
introspection = infers the db from the data you already have input in the DB
createdAt DateTime @default(now()) #creates a timestamp when data is created
@@map("products") #will map our model with a different name(Product) to the ecommerce.products of our DB
'npx prisma db push' #changes will be applied to our MongoDB from our schema code
'npx prisma generate' #will generate a prisma client, which you can use to call different DB operations on, whenever you make changes to schema, you need to regenerate your prisma client
  import { PrismaClient } from '@prisma/client'
  const prisma = new PrismaClient()
Getting Prisma to work with NextJS:
https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices

45:00==============================================================================================================================================================================================================================
After introspecting our schema, we can now delete our dummy data
'npm run dev' #time to start building
created a new folder in src / app / add-product 'page.tsx' routing will load this automatically, we can navigate to it through localhost:3000/add-product
Error: Fixed = had to delete babl.rc and remove next/babel from config file, was causing a problem
Error: Our Tailwind classes are not working Fixed: added below code to 'tailwind.config.js'
/** @type {import('tailwindcss').Config} */

48:00==============================================================================================================================================================================================================================
className = "" #used by tailwind to style different elements and components
we get autocompletion with our tailwind VSCode extension, you can hover over the individual items in className to see what each one does with detail
'Shift' + 'Alt' + F = shortcut to reorder all classes in correct order(windows only, doesn't work on linux)
Daisy UI components:
https://daisyui.com/components/input/
What daisy UI does is it already has pre-styled all tailwindCSS components, so you don't need to do it manually, you can search for whatever component you need above, and hover over to see tailwindCSS inputs in VSCode
<input className="mb-3 w-full input input-bordered" /> #will create a rounded box input with predesigned tailwindCSS from daisyUI with custom classNames we searched up
'layout.tsx' is the root layout, where all styling will be applied to every page in your app, which returns your components/pages as children 
<main className="p-4 max-w-7xl m-auto min-w-[300px]"> #created a new main tag that will apply styling of padding and max-width/min width[with a custom value] and auto-margin center to all of our pages

60:00==============================================================================================================================================================================================================================
export const metadata = {
    title: "Add Product"
} #overrides the default metadata in our 'layout.tsx' file, will change the title but only for the page where we put the 'export const metadata'
when we submit the form, we want to store a new product in our database, 1) turn it into a client component so we can execute JS, 2)take input of form and send by a fetch to server endpoint and add a product to a DB
  you can't make server operations on the client, because it exposes the DB credentials on the client, why you must route connections like this over a server 
NextJS Server Actions:
https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
Next JS server actions will allow you to a way to do server mutation directly through components without having to set up a server endpoint, just put a function inside of component and you can alter DB
Error : Cannot find name 'redirect'.
https://nextjs.org/docs/app/building-your-application/routing/redirecting

1:12:00============================================================================================================================================================================================================================
You can also use react hooks for validation, but need to make it a client component to use JS actions
Later in tutorial, we are going to protect the route 'page.tsx' add product page by making it so you can only add a product if you are logged in with the right credentials, after we add authentication
Where to get our images for products(free):
https://unsplash.com/
search product images, click, 'copy image address' and paste into our add-product page ImageUrl
You can use chatGPT to write product descriptions instead of mentally vomiting over the product or whatever below is:
In the diablo immortal words of blizzard entertainment; Do you guys not have a phone? Is that 2012 calling?  With this retro Kamera-9001 every day is now 2012, 
  you can now be pretend pretentious(all the cool kids now have apple vision pro XL magnum) and the I like to watch 'Kamera Guy' tfw no OF GF. It will only cost you 6,000$(2012 money, now 15,000$), 
  it only has one lens-so 2012- so retro - RIP Kony
In our DB 15000 isn't 15000$, 150.00, 1500000 = 15,000.00 (if it doesn't make dollas it doesn't make cents)
Just Tested our First Add Product through server components without JS or an API - it works, added succesfully to MongoDB, going to use ChatGPT when uploading for the next products, saves time/mental energy
there was no loading screen when we were inputting our Data into the DB, we can create a hook, we are going to implement it into our button
import { ComponentProps } from "react";
type FormSubmitButtonProps = {
  children: React.ReactNode, #children: prop that allows us to whatever we pass in our component will be passed to the <button>THIS TEXT WILL BE PASSED HERE</button>
  className?: string, #will allow us to change the styling, className?(questionmark makes it optional) which doesn't need to be passed
} & ComponentProps<"button"> #an import from react that allows us to use all the prop(erties) from a normal <"button"> would accept, works with type, not interface

export default function FormSubmitButton(
    {children, className} : FormSubmitButtonProps #will hand our props to this function
) {
  return (
    <button type="submit">
      {children} #will be changed by the children: tag above
    </button>
  )
}

1:21:00=============================================================================================================================================================================================================================
We now have a loading button that should disable our add product submit form button component when it is sending data to the server, then redirects us to main page
the server action is treated as a post request
He added 2 more products to the DB, commented out the redirect before uploading so it didn't kick him back to main page
Created a new file called 'error.tsx' in src / app #will be the page that automatically gets shown when you have an error, naming conventions are important for this file
all 'error.tsx' components MUST be "use client";

1:30:00=============================================================================================================================================================================================================================
in src / app 'page.tsx' removed ALL boilerplate code, started with a fresh <div>
by default pages in the app directory are server components, so we can do database configs and async functions, because it will be executed on the server, not the client.. unless we say "use client"
  making DB requests and using credentials is safe, because it will not be leaked to the client, so we can use prisma here safely
export default async function Home() {
  const products = await prisma.product.findMany({
    orderBy: {id: "desc"}
  }) #will check our DB for product using the findMany function, and order them by id descending, so newest products first
in src / app / components 'ProductCard.tsx' for our product card, which will pull the data from our DB and post it on main page

1:40:00=============================================================================================================================================================================================================================
we are going to create another component in components folder called 'PriceTag.tsx'
Now we need to take our pricetag component and place it in our 'ProductCard.tsx' 
Below adds an image to our productcard, DaisyUI documentation recomends wrapping image in a figure, the image component is 'import Image from "next/image";' width and height are relative, and will change depending on screen size
      <figure>
        <Image
          src={product.imageUrl}
          alt={product.name}
          width={800}
          height={400}
          className="h-48 object-cover" #h-48 = sets the height, object-cover = center crops image
        />
      </figure>
const isNew = Date.now() - new Date(product.createdAt).getTime() <1000 * 60 * 60 * 24 * 7; #miliseconds x 60 seconds x 60 minutes x 24 hours x 7 days, if product is newer than 7 days =  true
Now we need to remove our hardcoded <ProductCard /> and make it dynamic and load in all the props we input into our DB
      <div className="hero rounded-xl bg-base-200">
        <Image 
        src={products[0].imageUrl}
        alt={products[0].name}
        width={400}
        height={800}
        className="w-full max-w-sm rounded-lg shadow-2xl"
        priority
        />
      </div> #will load our hero image, using DaisyUI Docs, it will use those className's to create our hero image, loading the [0] most recent product, the 'priority' tag will tell nextJS to load this item first

1:50:00==============================================================================================================================================================================================================================
<div className="hero-content flex-col lg:flex-row"> #how you make tailwindCSS responsive, will be flex-column(vertically) until large screens and then turn into flex-row(horizontally)
  the one without the modifier will be your default for small screens the lg: will be the modifier for large screens or larger
            <Link
              href={"/products/" + products[0].id}
              className="btn btn-primary"
            > #will create a link to the /products/[id] with id being whichever product is attached to the unique id and it's own product page
<div className="my-4 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"> #responsive grid
        {products.slice(1).map((product) => ( #map turns each product in an array to it's own product card, which we rended with our ProductCard component
          <ProductCard key={product.id} product={product} /> #renders dynamic with unique id for product_id
        ))}
      </div>

1:58:00=============================================================================================================================================================================================================================
Grid works. but need to add more products, only have 3 - will need >7ish, tedious work, will do tomo, future sean problem
the reason why you set up the<Image width={800}> is so that certain breakpoints (764pixel for large) will still have an image. even though the image is still relative based on the screen size
by default server components in react are statically cached, all products are fetched when we compile the project, even if we add new products, they will not appear
as soon as you add a search component in react JS it is automatically dynamically rendered, instead of static
next we are going to set up our src /  app  / 'products' / [id] 'page.tsx' #new file, the [] are critical for routing, page.tsx will render the product with the relevant unique id for each product
we created another file in src / app 'not-found.tsx' #will be the default page that gets loaded when a user tries to go to a page that does not exist (404), name of file is important for routing
now that we created a new 404 page, we can redirect to it dynamically, 

2:10:00=============================================================================================================================================================================================================================
Added 6 more products this morning, used chat gpt to write product descriptions, way faster.  Can test our responsive grid layout now
Metadata, in order to add metadata dynamically(product name, etc) we need to create a function, we can't do what we did before with metadata: ...
spelling is important for this function or nextJS will not recgonize it, it also must be async/promise because it needs to fetch the data from the DB
since we will be reusing this data later on in our code, we should cache it so we don't need to fetch it twice, it is done automatically if you use the 'fetch' function in JS
const getProduct = cache(async (id: string) => {
  const product = await prisma.product.findUnique({
    where: { id },
  });
  if (!product) notFound();
  return product;
});

export async function generateMetadata({
  params: { id },
}: ProductPageProps): Promise<Metadata> {
  const product = await getProduct(id);
  return {
    title: product.name,
    description: product.description,
    openGraph: {
      images: [{ url: product.imageUrl }],
    },
  };
}

Next we need to create a loading page to run while data is being fetched from our DB; src / app / 'loading.tsx' #name must be exact
Next we need to create the shopping cart in our DB and add a button, start in 'schema.prisma' file to create a new table;
we could make the changes by using dummy data in our MongoDB and then using introspection again to change the schema, but it is actually easier to modify the schema and then push the changes to our DB
model Cart {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
model CartItem {
  id        String @id @default(auto()) @map("_id") @db.ObjectId
  productId String @db.ObjectId
  quantity  Int
  cartId    String @db.ObjectId
} #added 2 models, one for our Cart, and items in the Cart

2:20:00=========================================================================================================================================================================================================================
we need to tell prisma what each id belongs to which model and they work with eachother(joins), for this we can use relations,  
  product   Product @relation(fields: [productId], references: [id]) #will add a relationship between CartItem and Product after you reformat, shortcut below
Ctrl + Shift + 'I' = Reformats code, 
  CartItem    CartItem[] #was added to Product model after we reformatted
now we need to do the same for our cart, 
cart      Cart    @relation(fields: [cartId], references: [id]) #adds a relationship between CartItem and Cart
CartItem  CartItem[] #same thing was added to our Cart model, will allow us to fetch all CartItems that belong to a particular cart, we renamed in to 'items  CartItem[]'
naming conventions are lowercase, and plural for MongoDb
@@map("carts") #will map our carts collection to our mongoDB database
@@map("cartitems") #same for our cartitems, same naming convention for our DB
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade) #what this does if we delete a product, all the card items containing it will also be deleted
'npx prisma db push' #will push all of our DB changes to our mongoDB server, created 2 new collections one for 'carts' and one for 'cartitems'
'npx prisma generate' #regenerate prisma client with new schema, remember everytime you make changes to DB to do this, so our new models will be available
Next we want to add a button to add item to our cart and a success message to let our customer know it was added succesfully
Only a client component can contain state, so we can wrap our button with the client component logic, and the rest of our page can remain a server component(more efficient)
src / app / products / [id] 'AddToCartButton.tsx'
We added a svg file, forgot to use "use client" for this component, fixed everything, looks good
now we need to add a server component for our client component, created 'actions.ts' in the same directory, we can use server actions in client components if it is in a seperate file

2:30:00=======================================================================================================================================================================================================================
src / app / lib / db 'cart.ts' #created for seperate server components to be used in a client component page
we are going to store the user in a cookie, to see if the user is logged in before we create a cart, in production this should be more secure(encrypted card.id, so user can't just modify cookies/ids)
  cookies also need additional security settings which we aren't doing in this tutorial, would also need secure settings in production
export async function createCart() {
  const newCart = await prisma.cart.create({
    data: {},
  });

  cookies().set("localCartId", newCart.id);
} #will create a cart
export async function getCart() {
  const localCartId = cookies().get("localCartId")?.value;
  const cart = localCartId
    ? await prisma.cart.findUnique({
        where: {
          id: localCartId,
        },
        include: { items: { include: { product: true } } },
      })
    : null;

  return cart;
} #will fetch a cart, if it exists, add products/items, else return null

2:40:00========================================================================================================================================================================================================================
export type CartWithProducts = Prisma.CartGetPayload<{
  include: { items: { include: { product: true } } };
}>; #will allow us to use our cart in our server components

2:50:00========================================================================================================================================================================================================================
We need to use startTransition(()) hook so if an error occurs, it will stay serverside and won't crash the page/app
const [isPending, StartTransition] = useTransition(); # how we initialize variables and naming convention, and the react hook useTransition we will be using to handle our onClick
  #useTransition takes care of handling the error and loading state properly
const [success, setSuccess] = useState(false); #used for success message and loading state with a boolean value, how it handles onClick below
<button className="btn btn-primary" onClick={() => {
        setSuccess(false);
        startTransition(async () => {
          await incrementProductQuantity(productId);
          setSuccess(true);
        }) #how we implemented the onClick handling with startTransition function, which will increment or add product, then setSuccess to (true) so we can show a success message
      </button> #placed following logic below to display success message or loading spinner after our button
      {isPending && <span className="loading loading-spinner loading-md " />}
      {!isPending && success && (
        <span className="text-success">Added to Cart!</span>
      )}

Tested our add to cart feature, works, code looks pretty rough in db though:
_id
65ff378b8a6a37cea5671cc2
productId
65fd58ee90b4cfa1d26c644a
quantity
1
cartId
65ff378a8a6a37cea5671cc1
It should also create a cookie, F12 -> Application Tab -> Cookies to test, how the real ecommerce sites do it(use cookies)
We are going to need to figure out a way to automatically delete a cart after a certain duration so we don't get too many carts stored up from AFK carts

3:00:00=========================================================================================================================================================================================================================
He deleted both cart and cartitems in DB, everything still worked, tested race conditions by double clicking, simply added a cart item and increased the quantity to 2
now it's time to add a navbar and footer so we can navigate between pages
src / app / 'Navbar' / 'Navbar.tsx'
we want our Navbar to be available for every page on our webapp so we put the <Navbar> component in the app / 'layout.tsx' 

3:10:00=========================================================================================================================================================================================================================
Added a search to the navbar, we need to use a server action to do our search, since our navbar isn't a 'use client' component, we can put the server action in the navbar directly
async function searchProducts(formData: FormData) {
    "use server";
    const searchQuery = formData.get("searchQuery")?.toString();
    if (searchQuery) {
        redirect("/search?query=" + searchQuery); 
    } #will redirect the form data to the URL+/search?query=<whatever you typed in search>
doesn't require any JS, so our search will work even without being a client side JS component, in order to maintain navbar as a server component created in app / Navbar / 'ShoppingCartButton.tsx' in order to add JS

3:21:00=========================================================================================================================================================================================================================
We added a dropdown link to our cart page, now we need to actually set up the "/cart" page
src / app / cart / 'page.tsx'

3:30:00=========================================================================================================================================================================================================================
<div className="flex flex-wrap items-center gap-3"> #flex-wrap will cause it to start a second row if it can not fit
const quantityOptions: JSX.Element[] = [];
  for (let i = 1; i <= 99; i++) {
    quantityOptions.push(
      <option value={i} key={i}>
        {i}
      </option>,
    ); #for loop to create 99 options but a switch aint one

3:40:00=========================================================================================================================================================================================================================
created new 'actions.ts' in src / app / cart / 'actions.ts' #created for logic in cart dropdown, delete add, or change, and add to prisma DB

3:50:00=========================================================================================================================================================================================================================
 if (quantity === 0) {
    if (articleInCart) {
      await prisma.cartItem.delete({
        where: { id: articleInCart.id },
      });
    } #will delete the item in the cart if the user selects '0' option
The next step is to add user authentication so the user can log in and maintain the same cart, to handle authentication we are using 'nextauth.js'
Next-Auth.js.org(official docs):
https://next-auth.js.org/
There are many different providers you can choose to log in from(da gram, linkedIn, FB, google, etc) we are just going to set up the google provider
https://next-auth.js.org/providers/google
It has different DB adapters you can use, there is one for prisma and mongodb, makes it easy to store session and user data in mongodb
 https://next-auth.js.org/adapters
too implement google you need a project in the google cloud:
https://console.cloud.google.com/welcome
Create a new project, after that go to top left dropdown -> API's -> Credentials -> 0Auth consent Screen -> Create -> External 
Authorized redirect URI(What nextJS expects):
http://localhost:3000/api/auth/callback/google
Added Credentials(GOOGLE_CLIENT_ID / GOOGLE_CLIENT_SECRET) to .env file

4:00:00==========================================================================================================================================================================================================================
also added 'NEXTAUTH_URL="http://localhost:3000"' and NEXTAUTH_SECRET to .env file, secret can be any alphanumeric mix of characters, used for encrypting session cookie, both names are required to be the same, else error
src / app / 'api' / 'auth' / '[...nextauth]' / 'route.ts' the way next auth works is we have to set up a route handler or an API endpoint, under a very specific URL, every authentication request will go threw this URL 
above we created 3 new folders and one new file 'route.ts' for the route handler, the '[...nextauth]' is called a catch-all statement, and can handle many different routes and not just a single one
import prisma from "@/app/lib/db/prisma";
import { env } from "@/app/lib/env";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { NextAuthOptions } from "next-auth";
import { Adapter } from "next-auth/adapters";
import NextAuth from "next-auth/next";
import GoogleProvider from "next-auth/providers/google";
# lots of imports for a short file
Next we need to go into our src / 'layout.tsx' and set it up so it will use our session provider for our logged in user is available to our app, 
import { SessionProvider } from "next-auth/react"; #wrapped everything in our body with the <SessionProvider> component
"use client"; #created a new 'SessionProvider.tsx' and added one line below to turn our component into a client side component
export { SessionProvider as default } from "next-auth/react"; #takes in the default SessionProvider and exports it as a client side component
import SessionProvider from "./SessionProvider"; #will also need to change the import in our 'layout.tsx'

4:10:00=========================================================================================================================================================================================================================
Next we need to add models for our prisma schema for authentication in the DB 'schema.prisma' file:
https://authjs.dev/reference/adapter/prisma?_gl=1*18v7nsv*_gcl_au*MTY1NTY5MzU1Ni4xNzExMzg4Mjkx
model User #contains email account and username and image
model Account #stores google account in a seperate DB
model session #when the user is logged on, alternative to JWT authentication, when a user is logged in there is a session entry created in our DB, contains user ID and expiration date
now we need to connect a shopping cart to a user with their unique userId, copied and pasted models, made some changes to model cart
now we need to push our changes to the DB again, 'npx prisma db push', added sessions users, verificationtokens, and accounts models to our MongoDB
after that we need to regenerate our db 'npx prisma generate'
next we want to add a button in our navbar that shows the profile image of our user when they are logged in and a dropdown menu for them to logout
src / app / Navbar / 'UserMenuButton.tsx'

4:20:00===========================================================================================================================================================================================================================
tabIndex={0} #allows us to navigate with 'tab' in our UI

4:30:00===========================================================================================================================================================================================================================
had to fix a bug for some reason '@' isn't working for our app, need to use '../'
Now that we have authentication sorted out, we can now add some protection to our 'add-product' page, so that not anyone can add a product to our DB
session.user.id = user.id; #was throwing an error, in order to fix we need to...
go into root directory, above src and create a new folder called '@types' and create a new file called 'next-auth.d.ts' #d.ts files are typescript decoration files, that allow us to make changes to existing types
declare module "next-auth" {
  interface Session {
    user: {
      id: string;
    } & DefaultSession["user"];
  }
} #will give us a user id of type string and all the other values available to the user with DefaultSession["user"]
ERROR!: '=>' expected. 
  callbacks: {
    session: ({session, user}) {
      session.user.id = user.id;
      return session;
    },
  }, #asked AI and it told me to replace above with below, deviated from tutorial, but error is gone
callbacks: {
    session: ({ session, user }: { session: any; user: any }) => {
      session.user.id = user.id;
      return session;
    },
  },

4:40:00=========================================================================================================================================================================================================================
now we need to implement the logic that merges the anonymous cart with the user cart when you log in, like how it works in amazon
function mergeCartItems(...cartItems: CartItem[][]) {} # will take in ...cartItems as an array of an array, so any number of carts can be merged, 2, 3 etc
 return cartItems.reduce((acc, items) => {
    items.forEach((item) => {
      const existingItem = acc.find((i) => i.productId === item.productId);
      if (existingItem) {
        existingItem.quantity += item.quantity;
      } else {
        acc.push(item);
      }
    });
    return acc;
  }, [] as CartItem[]);
} #goes through each cart item and combines the items

4:50:00========================================================================================================================================================================================================================
had a bug, fixed it, '->' is incorrect, '=>' is correct, was late, was tired, fixed now
cookies().set("localCartId", ""); #this is how you delete a cookie in NextJS
after creating our merge function, we want to call it right when the user has logged in, also how amazon handles it
if an error is thrown even at the end of the tx(transaction), it will not go threw, even though it is thrown after they all go threw and the merge will fail
'cart.ts' whenever you fetch cookies, the route that uses that session is automatically dynamically rendered

5:00:00========================================================================================================================================================================================================================
When we show the cart of the user, the data is different for each user, so we don't want to cache our data on our backend - whenever you use cookies, the page will be rendered dynamically automatically
  why we don't need to add revalidate 0 to our cart page, after running 'npm run build' the page will show a lambda symbol which shows that it is not cached
'npm run build' #will build the code for production mode
For the next part we will implement pagination, so we won't show all our products at once - future sean will need to add new products - future shawn problem, he used a for loop in 'page.tsx' of add-product
for (let i = 0; i < 50, i++) {
  await prisma.product.create({
  data: {name, description, imageUrl, price }, 
});
}
src / app / components / 'PaginationBar.tsx' 
we don't want to show all 50 items on the same page, we want to create a subset that calculates the page numbers
const maxPage = Math.min(totalPages, Math.max(currentPage + 4, 10)) #.min returns smallest of values passed, .max opposite, currentPage +4 will be max 13=17, and on page 1 will show pages up until 10 or else it would be small
  if there is no page +4 then it will show total pages instead
for (let page = minPage; page <= maxPage; page++) {
    numberedPageItems.push(
        <Link href={"/?page=" + page} key={page} className={`join-item btn ${currentPage === page ? "btn-active pointer-events-none" : ""}`}>
#we declared numberedPageItems above, for each page it will push a link that has the page number, with a key, with a special daisy UI classname `join-item` combining them into a single bar,
  if the current page is = page(the one you are on) it will become unclickable, else ""(nothing)

5:10:00===========================================================================================================================================================================================================================
After testing, our bar is too large if the screen is too small, we need to make it responsive
return <div className="join hidden sm:block">{numberedPageItems}</div>; #join is a keyword for the look of our bar, will be hidden by default, small screens will be a block with arrows
<> </> don't forget fragments, you can not return a div by itself, you must always have a parent element
<div className="join block sm:hidden">{currentPage > 1 && <Link href={"?page=" + (currentPage - 1)} className="btn join-item"> #below the above code, we will place another div a link that will be hidden on small screens
  and shown on larger screens, the link will take us to current page -1, so the previous page, if the current page is greater than 1(can't go negative pages)
created 2 more, one for current page and one for next page

5:15:00===========================================================================================================================================================================================================================
In our home src / app / 'page.tsx' we need to add a prop for getting the page information to feed into our pagination bar
interface HomeProps {
  searchParams: { page: string}
}
to avoid magic numbers in your code that will cause later confusesean, store your values in a variable that is aptly named
const totalItemCount = await prisma.product.count(); # will get an amount of items in DB, that will allow us to create the correct number of pages dynamically
const totalPages = Math.ceil((totalItemCount - heroItemCount) / pageSize) #will get the correct number of pages, subtract the hero item count(page 1) and divide by page size, math.ceil will round up
Order of operations: PEMDAS
We want to skip the items on the first page if we are on the second, so we will add the skip to our prisma query
const products = await prisma.product.findMany({
    orderBy: { id: "desc" },
    skip: (currentPage - 1) * pageSize + (currentPage === 1 ? 0 : heroItemCount) #if we are on the first page, it won't skip any, if we are on any page it will subtract 1 from current page and remove that many items * pagesize
    take: pageSize + (currentPage === 1? heroItemCount : 0) #if you are on page one, it will take the heroitemcount from the pagesize, and if not, it will return all items
});

5:25:00===========================================================================================================================================================================================================================
Next we want to implement search functionality - already built search box with query URL param
src / app / search / 'page.tsx'
export default async function SearchPage({
  searchParams: { query },
}: SearchPageProps) {
  const products = await prisma.product.findMany({
    where: {
      OR: [
        { name: { contains: query, mode: "insensitive" } },
        { description: { contains: query, mode: "insensitive" } },
      ],
    },
    orderBy: { id: "desc" },
  });
  if (products.length === 0) {
    return <div className="text-center">No products found</div>;
  }
  return (
    <div className="grid grid-cols-1 gap-4 md:grid-cols-2 xl:grid-cols-3">
      {products.map((product) => (
        <ProductCard product={product} key={product.id} />
      ))}
    </div>
  );
}#prisma searches our product DB 'OR' keyword allows us to find any products that match any of the categories we give it, mode: "insensitive"  #doesn't need to be case sensitive, ID has a timestamp, will order them by date
  #if no products are found, it will give us a div that says no products found, if there are, it will return them 
Pagination was not added, added metadata that will update our tab info with the search query
Features wise the app is completed here, we still need to deploy it, 

5:35:00==========================================================================================================================================================================================================================
prisma extension is a new feature, because we can create anonymous shopping carts in our DB, we might accumulate alot of abandoned carts over time 
once the cookie is deleted(incognito mode) there is no way to make a connection to the anon shopping cart and the one on DB and retrieve it, they create a new one every time
we should delete them from time to time, we can check the updated at timestamp together with user id, then we want to delete it
we can use a relation query to change the cart and update the timestamp
src / app / cart / actions.ts
  if (quantity === 0) {
    if (articleInCart) {
      await prisma.cart.update({
        where: { id: cart.id },
        data: {
          items: {
            delete: { id: articleInCart.id },
          },
        },
      });
    }
ERROR: Messed up, added 50 naruto figurines, and pagination bar isn't showing any numbers for each page to click, they 'work' but don't show anything
  shadow clone no jutsu'ed myself straight into an error, FIXED: forgot {page} 
ERROR: Type 'ShoppingCart | null' is not assignable to type 'ShoppingCart'.
  Type 'null' is not assignable to type 'ShoppingCart'.
    Type 'null' is not assignable to type '{ items: ({ product: { id: string; description: string; imageUrl: string; name: string; price: number; createdAt: Date; updatedAt: Date; }; }
  & { id: string; productId: string; quantity: number; cartId: string; })[]; }'.
ERROR CODE:
export default async function Navbar() {
  const session = await getServerSession(authOptions);
  const cart = await getCart();
<ShoppingCartButton cart={cart} />
FIXED(maybe): maybe autocomplete? was found in 'cart.ts' idk why I put that there, I see null reasON, code still works
export async function getCart(): Promise<ShoppingCart | null> {
  const session = await getServerSession(authOptions);
Just going to ignore for now, don't want to break anything before I take pictures so I can git a job and escape this frozen decadent sh!thole and never have to deal with these brainwashed idiots again(canadians)
Need to add 7 more products with AI written product descriptseans, so I don't look like a major weeb - an almost universally hated creature - here(sh!thole canada) and Japan

5:40:00=========================================================================================================================================================================================================================
Next we need to update the other server actions file 'actions.ts' for our products
and finally our 'cart.ts' file in lib
everytime you get a new ORM/language/model, make sure you get an extension that allows you to get autocomplete , we won't have a tutorial holding our hand next time when we git a job
Prisma client extensions(used you to hook into queries and autoupdate/do something everytime you do an operation):
https://www.prisma.io/docs/orm/prisma-client/client-extensions
src / app / lib / db / 'prisma.ts' #where you need to add the extension to automatically update the updated at timestamp
delete export default prisma; 
rename all instances of 'prisma' to 'prismaBase' 
export const prisma = prismaBase.$extends({
  query: {
    cart: {
      async update({ args, query }) {
        args.data = { ...args.data, updatedAt: new Date() };
        return query(args);
      },
    },
  },
});#will allow us to hook into the queries ...args.data will keep all the existing arguments, and will add a new arg that will update the date giving the current timestamp
F2 = Shortcut to automatically rename all instances of a word in code 
ERROR: Tried to add the extension, got a wall of red text from all the errors, code broke, don't want to spend time fixing it, won't be needing it anyways, not for production code

5:45:00==========================================================================================================================================================================================================================
Last Section for the prisma client extension, you only need it to update the timestamp to remove excess carts, we finished 2 days ago with all the features working, just want to complete tutorial fully
Since it's not production we don't need this, just good to know about
We can use a cron-job to execute tasks that runs at a certain time interval
Vercel:
https://vercel.com/docs/cron-jobs
will check from time to time and delete all of our carts that havn't been touched in a while
Now it's time to deploy our code to production, so we can use our website over the internet, easiest way to deploy is by 'vercel.com' the company that created next.js, which is a hosting provider
vercel is optimized to deploy a nextJS project
Steps:
first you must deploy it to github, push your project to a repository(can be private) 
Sign up to vercel and connect it to your github
then you need to click on add-new, and just import
Before doing all that, you need to add a post install script in 'package.json' :
https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/vercel-caching-issue
Next you need to add IP address to MongoDB (allow connections from anywhere) :
  from the dashboard, go to 'Network Access' , Click on 'Add IP Address', click on 'Allow Access from Anywhere'
Import Project into vercel from github, 
Next go to project settings, 'Environment Variables' and add all of our .env variables we used for API's/DB MGMT

add the below code before importing to vercel for production:
{
  ...
    "scripts" {
      "postinstall": "prisma generate"
    }
  ...
}
it happens because the way vercel tries to cache the prisma client

ERROR while trying to deploy to vercel: 
Failed to compile.
src/app/api/auth/[...nextauth]/route.ts
Type error: Route "src/app/api/auth/[...nextauth]/route.ts" does not match the required types of a Next.js Route.
  "authOptions" is not a valid Route export field.
Error: Command "npm run build" exited with 1
I've been at this for ~6hours and have made no progress, if I remove the 'export' at start of below code, then I get another error, that I didn't export it to my navbar and a bunch of other files, 
export const authOptions: NextAuthOptions = {
