Features:
Completely dynamic product loading - products are not hardcoded, and will load chronologically
pagination - fast page loading - pre rendered and cached
cart - with total cost, subtotal, and quantity, server action nextJS feature, POST request
anonymous shopping cart - if you log out of account, new shopping cart will be created, and you can add items to it, and merge when you log back in
authentication - can log into accounts
checkout button is a dummy 
server side rendering - good for SEO(search engine optimization) - all data available when you open webpage
search functionality 
responsive design - changes based on screen size
tailwind css

npx create-next-app@latest
typescript: yes / eslint: yes / ESLint: yes / TailwindCSS: yes / src/directory: yes / AppRouter: yes / import alias: no
'npm run dev' to test if setup was successful localhost:3000

Installing prerequisite packages:
npm i daisyui prisma @prisma/client next-auth @auth/prisma-adapter prettier eslint-config-prettier prettier-plugin-tailwindcss

Setting up TailwindCSS:
https://tailwindcss.com/docs/installation
https://tailwindcss.com/docs/editor-setup
VSCode Extensions:
Tailwind CSS IntelliSense
Reccomended VS Code Settings:
'files.associations' settings to always open .css files in Tailwind CSS mode; top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'files: association' -> add item -> items: *.css Value: tailwind.css
  #after doing above, tailwindcss will now work in .css files (no more yellow warnings for the entire project!)
"files.associations":  {
  "*.css: "tailwindcss"
  }
'editor.quickSuggestions' =   top drop down menu -> file -> preferences -> settings or 'ctrl' + ',' search 'editor.quickSuggestions' -> add item -> strings: on
#by default VScode will not trigger completions when editing string content, updating the 'editor.quickSuggestions' settings may improve your experience, autosuggestions in strings
"editor.quickSuggestions': {
  "strings": true
}

20:00===============================================================================================================================================================================================================================
Daisy UI Configuration:
https://daisyui.com/docs/install/
DaisyUI is a components libarary, that has components prebuilt that are already configured, buttons, modal dialogues, progress bar, custom themes, theme generator - copy paste into tailwind file
https://daisyui.com/theme-generator/
Cool random generator for color palletes, or you can use a prebuilt like synthwave, I went with what was recomended
'tailwindconfig.js' #add below code to it, delete 'theme:' block
module.exports = {
  //...
  plugins: [require("daisyui")],
}
instead of hardcoding, if you set up a theme, you can change it all at once from one file, good to set up before you start coding, going with default for now wasted too much time fiddling around with palletes
after DaisyUI import, deleted everything from 'globals.css', except lines at top @tailwind
next, we need to import our automatic class ordering with tailwindcss and prettier, we already installed, but need to add to plugin to our prettier config
https://github.com/tailwindlabs/prettier-plugin-tailwindcss
npm install -D prettier prettier-plugin-tailwindcss
go into 'root' folder and create a new file called 'prettier.config.js' and added below code
module.exports = {
    plugins: ['prettier-plugin-tailwindcss'],
  } 
installed 'prettier - code formatter' extension
to make default for editing: top drop down File -> Preferences -> Settings - Change from 'none' to 'Prettier'

Error: Fixed:
Create file called .babelrc in your root directory and add this code:
{
  "presets": ["next/babel"],
  "plugins": []
}
And in .eslintrc, replace the existing code with:

{
  "extends": ["next/babel","next/core-web-vitals"]
}

For Future Sean: Prettier and ESlint can conflict, that's why you need to do the above fix every time you use it,
https://nextjs.org/docs/app/building-your-application/configuring/eslint#prettier
Installed ESLint extension aswell,
Next installed 'Prisma' extension, an ORM , it works with our MongoDB, will help us set up our schema file and gives us autocompletion, and helps with formatting
npm i zod #final package we need to install for our project,

27:00===============================================================================================================================================================================================================================
opengraph-image.png #downloaded for tut, the file needs that exact name and MUST be in src / app folder, it is used for the display image on pages like facebook
Now it's time to set up MongoDB:
https://www.mongodb.com/atlas/database
we already have an account from our last project, top left drop down -> New Project - NextJS-E-Commerce
MongoDB is good because they take care of a lot of things you would otherwise need to set up for yourself, such as replicas and switches, additional backup servers
created our first DB;DB name: ecommerce / Collection Name: products
added in our first product manually, by clicking 'INSERT DOCUMENT' in top right, Dummy Data Schema Below:
_id:65f87c86d239b4b6af147de7 ObjectId
name:"Product Name" String
description: "Product Description" String
imageUrl: "https://product-image.com: String
price:999 Int32
Floats are inacurrate, so we created our price as an integer32

34:00=============================================================================================================================================================================================================================
Prisma(what we are using to work with our DB):
https://www.prisma.io/
'npx prisma init' #will initialize prisma, creates a .env file with database URL placeholder, replace that string with the connect string from MongoDB
'npx prisma db pull' #we can tell prisma to pull the dummy data we added to our collection and add a schema from that data, so we don't have to set it up ourselves.
introspection = infers the db from the data you already have input in the DB
createdAt DateTime @default(now()) #creates a timestamp when data is created
@@map("products") #will map our model with a different name(Product) to the ecommerce.products of our DB
'npx prisma db push' #changes will be applied to our MongoDB from our schema code
'npx prisma generate' #will generate a prisma client, which you can use to call different DB operations on, whenever you make changes to schema, you need to regenerate your prisma client
  import { PrismaClient } from '@prisma/client'
  const prisma = new PrismaClient()
Getting Prisma to work with NextJS:
https://www.prisma.io/docs/orm/more/help-and-troubleshooting/help-articles/nextjs-prisma-client-dev-practices

45:00==============================================================================================================================================================================================================================
After introspecting our schema, we can now delete our dummy data
'npm run dev' #time to start building
created a new folder in src / app / add-product 'page.tsx' routing will load this automatically, we can navigate to it through localhost:3000/add-product
Error: Fixed = had to delete babl.rc and remove next/babel from config file, was causing a problem
Error: Our Tailwind classes are not working Fixed: added below code to 'tailwind.config.js'
/** @type {import('tailwindcss').Config} */

48:00==============================================================================================================================================================================================================================
className = "" #used by tailwind to style different elements and components
we get autocompletion with our tailwind VSCode extension, you can hover over the individual items in className to see what each one does with detail
'Shift' + 'Alt' + F = shortcut to reorder all classes in correct order(windows only, doesn't work on linux)
Daisy UI components:
https://daisyui.com/components/input/
What daisy UI does is it already has pre-styled all tailwindCSS components, so you don't need to do it manually, you can search for whatever component you need above, and hover over to see tailwindCSS inputs in VSCode
<input className="mb-3 w-full input input-bordered" /> #will create a rounded box input with predesigned tailwindCSS from daisyUI with custom classNames we searched up
'layout.tsx' is the root layout, where all styling will be applied to every page in your app, which returns your components/pages as children 
<main className="p-4 max-w-7xl m-auto min-w-[300px]"> #created a new main tag that will apply styling of padding and max-width/min width[with a custom value] and auto-margin center to all of our pages

60:00==============================================================================================================================================================================================================================
export const metadata = {
    title: "Add Product"
} #overrides the default metadata in our 'layout.tsx' file, will change the title but only for the page where we put the 'export const metadata'
when we submit the form, we want to store a new product in our database, 1) turn it into a client component so we can execute JS, 2)take input of form and send by a fetch to server endpoint and add a product to a DB
  you can't make server operations on the client, because it exposes the DB credentials on the client, why you must route connections like this over a server 
NextJS Server Actions:
https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations
Next JS server actions will allow you to a way to do server mutation directly through components without having to set up a server endpoint, just put a function inside of component and you can alter DB
Error : Cannot find name 'redirect'.
https://nextjs.org/docs/app/building-your-application/routing/redirecting

1:12:00============================================================================================================================================================================================================================
You can also use react hooks for validation, but need to make it a client component to use JS actions
Later in tutorial, we are going to protect the route 'page.tsx' add product page by making it so you can only add a product if you are logged in with the right credentials, after we add authentication
Where to get our images for products(free):
https://unsplash.com/
search product images, click, 'copy image address' and paste into our add-product page ImageUrl
You can use chatGPT to write product descriptions instead of mentally vomiting over the product or whatever below is:
In the diablo immortal words of blizzard entertainment; Do you guys not have a phone? Is that 2012 calling?  With this retro Kamera-9001 every day is now 2012, 
  you can now be pretend pretentious(all the cool kids now have apple vision pro XL magnum) and the I like to watch 'Kamera Guy' tfw no OF GF. It will only cost you 6,000$(2012 money, now 15,000$), 
  it only has one lens-so 2012- so retro - RIP Kony
In our DB 15000 isn't 15000$, 150.00, 1500000 = 15,000.00 (if it doesn't make dollas it doesn't make cents)
Just Tested our First Add Product through server components without JS or an API - it works, added succesfully to MongoDB, going to use ChatGPT when uploading for the next products, saves time/mental energy
there was no loading screen when we were inputting our Data into the DB, we can create a hook, we are going to implement it into our button
import { ComponentProps } from "react";
type FormSubmitButtonProps = {
  children: React.ReactNode, #children: prop that allows us to whatever we pass in our component will be passed to the <button>THIS TEXT WILL BE PASSED HERE</button>
  className?: string, #will allow us to change the styling, className?(questionmark makes it optional) which doesn't need to be passed
} & ComponentProps<"button"> #an import from react that allows us to use all the prop(erties) from a normal <"button"> would accept, works with type, not interface

export default function FormSubmitButton(
    {children, className} : FormSubmitButtonProps #will hand our props to this function
) {
  return (
    <button type="submit">
      {children} #will be changed by the children: tag above
    </button>
  )
}

1:21:00=============================================================================================================================================================================================================================
We now have a loading button that should disable our add product submit form button component when it is sending data to the server, then redirects us to main page
the server action is treated as a post request
He added 2 more products to the DB, commented out the redirect before uploading so it didn't kick him back to main page
Created a new file called 'error.tsx' in src / app #will be the page that automatically gets shown when you have an error, naming conventions are important for this file
all 'error.tsx' components MUST be "use client";

1:30:00=============================================================================================================================================================================================================================
in src / app 'page.tsx' removed ALL boilerplate code, started with a fresh <div>
by default pages in the app directory are server components, so we can do database configs and async functions, because it will be executed on the server, not the client.. unless we say "use client"
  making DB requests and using credentials is safe, because it will not be leaked to the client, so we can use prisma here safely
export default async function Home() {
  const products = await prisma.product.findMany({
    orderBy: {id: "desc"}
  }) #will check our DB for product using the findMany function, and order them by id descending, so newest products first
in src / app / components 'ProductCard.tsx' for our product card, which will pull the data from our DB and post it on main page

1:40:00=============================================================================================================================================================================================================================
we are going to create another component in components folder called 'PriceTag.tsx'
Now we need to take our pricetag component and place it in our 'ProductCard.tsx' 
Below adds an image to our productcard, DaisyUI documentation recomends wrapping image in a figure, the image component is 'import Image from "next/image";' width and height are relative, and will change depending on screen size
      <figure>
        <Image
          src={product.imageUrl}
          alt={product.name}
          width={800}
          height={400}
          className="h-48 object-cover" #h-48 = sets the height, object-cover = center crops image
        />
      </figure>
const isNew = Date.now() - new Date(product.createdAt).getTime() <1000 * 60 * 60 * 24 * 7; #miliseconds x 60 seconds x 60 minutes x 24 hours x 7 days, if product is newer than 7 days =  true
Now we need to remove our hardcoded <ProductCard /> and make it dynamic and load in all the props we input into our DB
      <div className="hero rounded-xl bg-base-200">
        <Image 
        src={products[0].imageUrl}
        alt={products[0].name}
        width={400}
        height={800}
        className="w-full max-w-sm rounded-lg shadow-2xl"
        priority
        />
      </div> #will load our hero image, using DaisyUI Docs, it will use those className's to create our hero image, loading the [0] most recent product, the 'priority' tag will tell nextJS to load this item first

1:50:00==============================================================================================================================================================================================================================
<div className="hero-content flex-col lg:flex-row"> #how you make tailwindCSS responsive, will be flex-column(vertically) until large screens and then turn into flex-row(horizontally)
  the one without the modifier will be your default for small screens the lg: will be the modifier for large screens or larger
            <Link
              href={"/products/" + products[0].id}
              className="btn btn-primary"
            > #will create a link to the /products/[id] with id being whichever product is attached to the unique id and it's own product page
<div className="my-4 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4"> #responsive grid
        {products.slice(1).map((product) => ( #map turns each product in an array to it's own product card, which we rended with our ProductCard component
          <ProductCard key={product.id} product={product} /> #renders dynamic with unique id for product_id
        ))}
      </div>

1:58:00=============================================================================================================================================================================================================================
Grid works. but need to add more products, only have 3 - will need >7ish, tedious work, will do tomo, future sean problem
the reason why you set up the<Image width={800}> is so that certain breakpoints (764pixel for large) will still have an image. even though the image is still relative based on the screen size
by default server components in react are statically cached, all products are fetched when we compile the project, even if we add new products, they will not appear
as soon as you add a search component in react JS it is automatically dynamically rendered, instead of static
next we are going to set up our src /  app  / 'products' / [id] 'page.tsx' #new file, the [] are critical for routing, page.tsx will render the product with the relevant unique id for each product
we created another file in src / app 'not-found.tsx' #will be the default page that gets loaded when a user tries to go to a page that does not exist (404), name of file is important for routing
now that we created a new 404 page, we can redirect to it dynamically, 

2:10:00=============================================================================================================================================================================================================================
TODO: Add MetaData to the page





















