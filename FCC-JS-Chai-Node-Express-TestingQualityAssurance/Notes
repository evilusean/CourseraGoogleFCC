Start : 24July2025

As your programs or web applications become more complex, you'll want to test them to make sure that new changes don't break their original functionality.
In the Quality Assurance Certification, you'll learn how to write tests with Chai to ensure your applications work the way you expect them to.
Then you'll build a chat application to learn advanced Node and Express concepts. You'll also use Pug as a template engine, Passport for authentication, 
  and Socket.io for real-time communication between the server and connected clients.

Learn How JavaScript Assertions Work ======================================================================================================================================================
Working on these challenges will involve you writing your code using one of the following methods:
Clone this GitHub repo and complete these challenges locally.
https://github.com/freeCodeCamp/boilerplate-mochachai/
Use a site builder of your choice to complete the project. Be sure to incorporate all the files from our GitHub repo.
Within tests/1_unit-tests.js under the test labeled #1 in the Basic Assertions suite, change each assert to either assert.isNull or assert.isNotNull 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    'test('#isNull, #isNotNull', function () {
      assert.isNull(null, 'This is an optional error description - e.g. null is null');
      assert.isNotNull(1, '1 is not null');
    });' # how to asset isNull and isNotNull

Test if a Variable or Function is Defined ==================================================================================================================================================
Within tests/1_unit-tests.js under the test labeled #2 in the Basic Assertions suite, change each assert to either
assert.isDefined() or assert.isUndefined() to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#isDefined, #isUndefined', function () {
      assert.isDefined(null, 'null is not undefined');
      assert.isUndefined(undefined, 'undefined IS undefined');
      assert.isDefined('hello', 'A string is not undefined');
    });

Use Assert.isOK and Assert.isNotOK =========================================================================================================================================================
isOk() will test for a truthy value, and isNotOk() will test for a falsy value.
To learn more about truthy and falsy values, try our Falsy Bouncer challenge.
Within tests/1_unit-tests.js under the test labeled #3 in the Basic Assertions suite, change each assert to either assert.isOk() or assert.isNotOk()
to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#isOk, #isNotOk', function () {
      assert.isNotOk(null, 'null is falsey');
      assert.isOk("I'm truthy", 'A string is truthy');
      assert.isOk(true, 'true is truthy');
    });

Test for Truthiness =========================================================================================================================================================================
isTrue() will test for the boolean value true and isNotTrue() will pass when given anything but the boolean value of true.
assert.isTrue(true, 'This will pass with the boolean value true');
assert.isTrue('true', 'This will NOT pass with the string value "true"');
assert.isTrue(1, 'This will NOT pass with the number value 1');
isFalse() and isNotFalse() also exist, and behave similarly to their true counterparts except they look for the boolean value of false.
Within tests/1_unit-tests.js under the test labeled #4 in the Basic Assertions suite, 
  change each assert to either assert.isTrue or assert.isNotTrueto make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
test('#isTrue, #isNotTrue', function () {
      assert.isTrue(true, 'true is true');
      assert.isTrue(!!'double negation', 'Double negation of a truthy value is true');
      assert.isNotTrue({ value: 'truthy' }, 'Objects are truthy, but are not boolean values');
    });

Use the Double Equals to Assert Equality ====================================================================================================================================================
equal() compares objects using ==.
Within tests/1_unit-tests.js under the test labeled #5 in the Equality suite, change each assert to either assert.equal or assert.notEqual 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#equal, #notEqual', function () {
      assert.equal(12, '12', 'Numbers are coerced into strings with ==');
      assert.notEqual({ value: 1 }, { value: 1 }, '== compares object references');
      assert.equal(6 * '2', '12');
      assert.notEqual(6 + '2', '12');
    });

Use the Triple Equals to Assert Strict Equality ============================================================================================================================================
strictEqual() compares objects using ===.
Within tests/1_unit-tests.js under the test labeled #6 in the Equality suite, change each assert to either assert.strictEqual or assert.notStrictEqual 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
   test('#strictEqual, #notStrictEqual', function () {
      assert.notStrictEqual(6, '6');
      assert.strictEqual(6, 3 * 2);
      assert.strictEqual(6 * '2', 12);
      assert.notStrictEqual([1, 'a', {}], [1, 'a', {}]);
    });

Assert Deep Equality with .deepEqual and .notDeepEqual =====================================================================================================================================
deepEqual() asserts that two objects are deep equal.
Within tests/1_unit-tests.js under the test labeled #7 in the Equality suite, 
  change each assert to either assert.deepEqual or assert.notDeepEqual to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#deepEqual, #notDeepEqual', function () {
      assert.deepEqual({ a: '1', b: 5 }, { b: 5, a: '1' }, "The order of keys doesn't matter");
      assert.notDeepEqual({ a: [5, 6] }, { a: [6, 5] }, 'The order of array elements does matter');
    });

Compare the Properties of Two Elements ======================================================================================================================================================
Within tests/1_unit-tests.js under the test labeled #8 in the Comparisons suite, 
  change each assert to either assert.isAbove or assert.isAtMost to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#isAbove, #isAtMost', function () {
      assert.isAtMost('hello'.length, 5);
      assert.isAbove(1, 0);
      assert.isAbove(Math.PI, 3);
      assert.isAtMost(1 - Math.random(), 1);
    });

Test if One Value is Below or At Least as Large as Another ==================================================================================================================================
Within tests/1_unit-tests.js under the test labelled #9 in the Comparisons suite, 
  change each assert to either assert.isBelow or assert.isAtLeast to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
   test('#isBelow, #isAtLeast', function () {
      assert.isAtLeast('world'.length, 5);
      assert.isAtLeast(2 * Math.random(), 0);
      assert.isBelow(5 % 2, 2);
      assert.isBelow(2 / 3, 1);
    });

Test if a Value Falls within a Specific Range ================================================================================================================================================
'.approximately(actual, expected, delta, [message])' #syntax for testing a range
  Asserts that the actual is equal to expected, to within a +/- delta range.
Within tests/1_unit-tests.js under the test labeled #10 in the Comparisons suite, change each assert to assert.approximately to make the test pass (should evaluate to true).
Choose the minimum range (3rd parameter) to make the test always pass. It should be less than 1.
    test('#approximately', function () {
      assert.approximately(weirdNumbers(0.5), 1, 0.5);
      assert.approximately(weirdNumbers(0.2), 1, 0.8);
    });

Test if a Value is an Array ===================================================================================================================================================================
Within tests/1_unit-tests.js under the test labeled #11 in the Arrays suite, change each assert to either
  assert.isArray or assert.isNotArray to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#isArray, #isNotArray', function () {
      assert.isArray('isThisAnArray?'.split(''), 'String.prototype.split() returns an array');
      assert.isNotArray([1, 2, 3].indexOf(2), 'indexOf returns a number');
    });

Test if an Array Contains an Item =============================================================================================================================================================
Within tests/1_unit-tests.js under the test labeled #12 in the Arrays suite,
  change each assert to either assert.include or assert.notInclude to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('Array #include, #notInclude', function () {
      assert.notInclude(winterMonths, 'jul', "It's summer in july...");
      assert.include(backendLanguages, 'javascript', 'JS is a backend language');
    });

Test if a Value is a String ===================================================================================================================================================================
isString or isNotString asserts that the actual value is a string.
Within tests/1_unit-tests.js under the test labeled #13 in the Strings suite, change each assert to either assert.isString or assert.isNotString 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#isString, #isNotString', function () {
      assert.isNotString(Math.sin(Math.PI / 4), 'A float is not a string');
      assert.isString(process.env.PATH, 'An env variable is a string (or undefined)');
      assert.isString(JSON.stringify({ type: 'object' }), 'JSON is a string');
    });

Test if a String Contains a Substring =========================================================================================================================================================
include() and notInclude() work for strings too! include() asserts that the actual string contains the expected substring.
Within tests/1_unit-tests.js under the test labeled #14 in the Strings suite, change each assert to either assert.include or assert.notInclude 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('String #include, #notInclude', function () {
      assert.include('Arrow', 'row', "'Arrow' contains 'row'");
      assert.notInclude('dart', 'queue', "But 'dart' doesn't contain 'queue'");
    });

Use Regular Expressions to Test a String =======================================================================================================================================================
match() asserts that the actual value matches the second argument regular expression.
Within tests/1_unit-tests.js under the test labeled #15 in the Strings suite, change each assert to either assert.match or assert.notMatch 
  to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#match, #notMatch', function () {
      const regex = /^#\sname\:\s[\w\s]+,\sage\:\s\d+\s?$/;
      assert.match(formatPeople('John Doe', 35), regex);
      assert.notMatch(formatPeople('Paul Smith III', 'twenty-four'), regex);
    });

Test if an Object has a Property ===============================================================================================================================================================
'property' asserts that the actual object has a given property.
Within tests/1_unit-tests.js under the test labeled #16 in the Objects suite, change each assert to either 
  assert.property or assert.notProperty to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#property, #notProperty', function () {
      assert.notProperty(myCar, 'wings', "Cars don't have wings");
      assert.property(airlinePlane, 'engines', 'Planes have engines');
      assert.property(myCar, 'wheels', 'Cars have wheels');
    });

Test if a Value is of a Specific Data Structure Type ============================================================================================================================================
#typeOf asserts that value's type is the given string, as determined by Object.prototype.toString.
Within tests/1_unit-tests.js under the test labeled #17 in the Objects suite, change each assert to 
  either assert.typeOf or assert.notTypeOf to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#typeOf, #notTypeOf', function () {
      assert.typeOf(myCar, 'object');
      assert.typeOf(myCar.model, 'string');
      assert.notTypeOf(airlinePlane.wings, 'string');
      assert.typeOf(airlinePlane.engines, 'array');
      assert.typeOf(myCar.wheels, 'number');
    });

Test if an Object is an Instance of a Constructor ==============================================================================================================================================
#instanceOf asserts that an object is an instance of a constructor.
Within tests/1_unit-tests.js under the test labeled #18 in the Objects suite, 
  change each assert to either assert.instanceOf or assert.notInstanceOf to make the test pass (should evaluate to true). Do not alter the arguments passed to the asserts.
    test('#instanceOf, #notInstanceOf', function () {
      assert.notInstanceOf(myCar, Plane);
      assert.instanceOf(airlinePlane, Plane);
      assert.instanceOf(airlinePlane, Object);
      assert.notInstanceOf(myCar.wheels, String);
    });

Run Functional Tests on API Endpoints using Chai-HTTP ==========================================================================================================================================
Mocha allows you to test asynchronous operations like calls to API endpoints with a plugin called chai-http.
The following is an example of a test using chai-http for a suite called 'GET /hello?name=[name] => "hello [name]"':
suite('GET /hello?name=[name] => "hello [name]"', function () {
  test('?name=John', function (done) {
    chai
      .request(server)
      .keepOpen()
      .get('/hello?name=John')
      .end(function (err, res) {
        assert.equal(res.status, 200, 'Response status should be 200');
        assert.equal(res.text, 'hello John', 'Response should be "hello John"');
        done();
      });
  });
});
The test sends a GET request to the server with a name as a URL query string (?name=John). In the end method's callback function, 
  the response object (res) is received and contains the status property.
The first assert.equal checks if the status is equal to 200. The second assert.equal checks that the response string (res.text) is equal to "hello John".
Also, notice the done parameter in the test's callback function. Calling it without an argument at the end of a test is necessary to signal that the asynchronous operation is complete.
Finally, note the keepOpen method just after the request method. Normally you would run your tests from the command line, or as part of an automated integration process, 
  and you could let chai-http start and stop your server automatically.
However, the tests that run when you submit the link to your project require your server to be up, so you need to use the keepOpen method to prevent chai-http from stopping your server.
Within tests/2_functional-tests.js, alter the 'Test GET /hello with no name' test (// #1) to assert the status and the text of the response to make the test pass. 
  Do not alter the arguments passed to the asserts.
There should be no URL query. Without a name URL query, the endpoint responds with hello Guest.

Run Functional Tests on API Endpoints using Chai-HTTP II ======================================================================================================================================
Within tests/2_functional-tests.js, alter the 'Test GET /hello with your name' test (// #2) to assert the status and the text of the response to make the test pass.
Send your name as a URL query by appending ?name=<your_name> to the route. The endpoint responds with 'hello <your_name>'.
    test('Test GET /hello with your name', function (done) {
      chai
        .request(server)
        .keepOpen()
        .get('/hello?name=xy_z')
        .end(function (err, res) {
          assert.equal(res.status, 200);
          assert.equal(res.text, 'hello xy_z');
          done();
        });
    });

Run Functional Tests on an API Response using Chai-HTTP III - PUT method ======================================================================================================================
As a reminder, this project is being built upon the following starter project cloned from GitHub.
When you test a PUT request, you'll often send data along with it. The data you include with your PUT request is called the body of the request.
To send a PUT request and a JSON object to the '/travellers' endpoint, you can use chai-http plugin's put and send methods:
chai
  .request(server)
  .keepOpen()
  .put('/travellers')
  .send({
    "surname": [last name of a traveller of the past]
  })
  ...
And the route responds with:
{
  "name": [first name],
  "surname": [last name],
  "dates": [birth - death years]
}
See the server code for the different responses to the '/travellers' endpoint.
Within tests/2_functional-tests.js, alter the 'Send {surname: "Colombo"}' test (// #3) and use the put and send methods to test the '/travellers' endpoint.
Send the following JSON object with your PUT request:
{
  "surname": "Colombo"
}
Check for the following within the request.end callback:
The status should be 200
The type should be application/json
The body.name should be Cristoforo
The body.surname should be Colombo
Follow the assertion order above - we rely on it. Also, be sure to remove assert.fail() once complete.
    test('Send {surname: "Colombo"}', function (done) {
      chai
        .request(server)
        .keepOpen()
        .put('/travellers')
        .send({ surname: "Colombo" })
        .end(function (err, res) {
          assert.equal(res.status, 200);
          assert.equal(res.type, 'application/json');
          assert.equal(res.body.name, 'Cristoforo');
          assert.equal(res.body.surname, 'Colombo');
          done();
        });
    });

Run Functional Tests on an API Response using Chai-HTTP IV - PUT method =====================================================================================================================
Now that you know how to test a PUT request, it's your turn to do it from scratch.
Within tests/2_functional-tests.js, alter the 'Send {surname: "da Verrazzano"}' test (// #4) and use the put and send methods to test the '/travellers' endpoint.
Send the following JSON object with your PUT request:
{
  "surname": "da Verrazzano"
}
Check for the following within the request.end callback:
The status should be 200
The type should be application/json
The body.name should be Giovanni
The body.surname should be da Verrazzano
Follow the assertion order above - we rely on it. Also, be sure to remove assert.fail() once complete.
    test('Send {surname: "da Verrazzano"}', function (done) {
      chai
        .request(server)
        .keepOpen()
        .put('/travellers')
        .send({ surname: "da Verrazzano" })
        .end(function (err, res) {
          assert.equal(res.status, 200);
          assert.equal(res.type, 'application/json');
          assert.equal(res.body.name, 'Giovanni');
          assert.equal(res.body.surname, 'da Verrazzano');
          done();
        });
    });

Simulate Actions Using a Headless Browser ===================================================================================================================================================
In the next challenges, you'll simulate human interaction with a page by using a headless browser.
Headless browsers are web browsers without a GUI. They are able to render and interpret HTML, CSS, and JavaScript the same way a regular browser would,
  making them particularly useful for testing web pages.
For the following challenges you'll use Zombie.js, which is a lightweight headless browser that doesn't rely on additional binaries to be installed. 
  But there are many other, more powerful headless browser options.
Mocha allows you to run some code before any of the actual tests run. This can be useful to do things like add entries to a database which will be used in the rest of the tests.
With a headless browser, before running tests, you need to visit the page you'll test.
The suiteSetup hook is executed only once at the beginning of a test suite.
There are several other hook types that can execute code before each test, after each test, or at the end of a test suite. See the Mocha docs for more information.
Within tests/2_functional-tests.js, immediately after the Browser declaration, add your project URL to the site property of the variable:
Browser.site = 'http://0.0.0.0:3000'; // Your URL here
Then at the root level of the 'Functional Tests with Zombie.js' suite, instantiate a new instance of the Browser object with the following code:
const browser = new Browser();
And use the suiteSetup hook to direct the browser to the / route with the following code. Note: done is passed as a callback to browser.visit, you should not invoke it.
suiteSetup(function(done) {
  return browser.visit('/', done);
});
const Browser = require('zombie');
Browser.site = 'http://0.0.0.0:3000'; // Your URL here
suite('Functional Tests with Zombie.js', function () {
  this.timeout(5000);
  const browser = new Browser();
  suiteSetup(function(done) {
    return browser.visit('/', done);
  });
  suite('Headless browser', function () {
    test('should have a working "site" property', function() {
      assert.isNotNull(browser.site);
    });
  });

Run Functional Tests Using a Headless Browser ================================================================================================================================================
On the page there's an input form. It sends data to the PUT /travellers endpoint as an AJAX request.
When the request successfully completes, the client code appends a <div> containing the information in the response to the DOM.
Here's an example of how to use Zombie.js to interact with the form:
test('Submit the surname "Polo" in the HTML form', function (done) {
  browser.fill('surname', 'Polo').then(() => {
    browser.pressButton('submit', () => {
      browser.assert.success();
      browser.assert.text('span#name', 'Marco');
      browser.assert.text('span#surname', 'Polo');
      browser.assert.elements('span#dates', 1);
      done();
    });
  });
});
First, the fill method of the browser object fills the surname field of the form with the value 'Polo'. fill returns a promise, so then is chained off of it.
Within the then callback, the pressButton method of the browser object is used to invoke the form's submit event listener. The pressButton method is asynchronous.
Then, once a response is received from the AJAX request, a few assertions are made confirming:
The status of the response is 200
The text within the <span id='name'></span> element matches 'Marco'
The text within the <span id='surname'></span> element matches 'Polo'
There is 1 <span id='dates'></span> element.
Finally, the done callback is invoked, which is needed due to the asynchronous test.
Within tests/2_functional-tests.js, in the 'Submit the surname "Colombo" in the HTML form' test (// #5), automate the following:
Fill in the form with the surname Colombo
Press the submit button
And within the pressButton callback:
Assert that status is OK 200
Assert that the text inside the element span#name is 'Cristoforo'
Assert that the text inside the element span#surname is 'Colombo'
Assert that the element(s) span#dates exist and their count is 1
Do not forget to remove the assert.fail() call.
    test('Submit the surname "Colombo" in the HTML form', function (done) {
      browser.fill('surname', 'Colombo').then(() => {
        browser.pressButton('submit', () => {
          browser.assert.success();
          browser.assert.text('span#name', 'Cristoforo');
          browser.assert.text('span#surname', 'Colombo');
          browser.assert.elements('span#dates', 1);
          done();
        });
      });
    });

Run Functional Tests Using a Headless Browser II =============================================================================================================================================
Within tests/2_functional-tests.js, in the 'Submit the surname "Vespucci" in the HTML form' test (// #6), automate the following:
Fill in the form with the surname Vespucci
Press the submit button
And within the pressButton callback:
Assert that status is OK 200
Assert that the text inside the element span#name is 'Amerigo'
Assert that the text inside the element span#surname is 'Vespucci'
Assert that the element(s) span#dates exist and their count is 1
Do not forget to remove the assert.fail() call.
    test('Submit the surname "Vespucci" in the HTML form', function (done) {
      browser.fill('surname', 'Vespucci').then(() => {
        browser.pressButton('submit', function() {
          browser.assert.success(); // Assert status is OK 200
          browser.assert.text('span#name', 'Amerigo'); // Assert name
          browser.assert.text('span#surname', 'Vespucci'); // Assert surname
          browser.assert.elements('span#dates', 1); // Assert dates count
          done();
        });

Advanced Node and Express ====================================================================================================================================================================
Now it's time to take a deep dive into Node.js and Express.js by building a chat application with a sign-in system.
To implement the sign-in system safely, you'll need to learn about authentication. This is the act of verifying the identity of a person or process.
In this course, you'll learn how to use Passport to manage authentication, Pug to create reusable templates for quickly building the front end, 
  and web sockets for real-time communication between the clients and server.

Set up a Template Engine =====================================================================================================================================================================
https://github.com/freeCodeCamp/boilerplate-advancednode/
https://forum.freecodecamp.org/t/advanced-node-and-express/567135
A template engine enables you to use static template files (such as those written in Pug) in your app. 
  At runtime, the template engine replaces variables in a template file with actual values which can be supplied by your server. 
  Then it transforms the template into a static HTML file that is sent to the client. 
  This approach makes it easier to design an HTML page and allows for displaying variables on the page without needing to make an API call from the client.
pug@~3.0.0 has already been installed, and is listed as a dependency in your package.json file.
Express needs to know which template engine you are using. Use the set method to assign pug as the view engine property's value:
app.set('view engine', 'pug');
After that, add another set method that sets the views property of your app to point to the ./views/pug directory. This tells Express to render all views relative to that directory.
Finally, use res.render() in the route for your home page, passing index as the first argument. This will render the pug template.
If all went as planned, your app home page will no longer be blank. Instead, it will display a message indicating you've successfully rendered the Pug template!
---------------ERROR - NOT PASSING TESTS, UNIRONIC 'BUT IT WORKS ON MY MACHINE' MOMENT -------------------------------------------------------------------------------------------------
https://a9d4db49-ded7-46e3-ac92-851bd7bc2c2f-00-1ew7ymkdcxghh.janeway.replit.dev/
Just spent 2 hours uploading all my files to 'Replit' - It still doesn't pass any of the tests, this is the third day, I've been trying to do this..
It runs locallF, It runs on Replit, I see when the tester on freecodecamp tries to connect in the terminal, I'm using the exact code they gave us, yet, somehow, it's not working
For Future Sean : https://replit.com/@evilusean/FCC-Node 
This is already the third day and around, what, like 4-8 hours I've dumped into this one challenge? I've used up all my VSCode monthly tokens trying to get this to run
Taking a break - frustrateSean 
https://forum.freecodecamp.org/t/advanced-node-and-express-clean-up-your-project-with-modules/751279/2 
^ above is the link to the forum post explaining that 'Glitch' doesn't work, which is why I put it on Replit, for future Sean, in case I have to ask on the forums, 
Every other post on the forum for this problem is over 4 years old, and none of them are relevant for the 'Read-Search-Ask' policy
Created a forum post, because I just want to move on, I need to finish this course and do another before the end of the month, on top of hundreds of Japanese flashcards a day
Hopefully by the time I finish updating WaniKani vocab lists, I will have an answer and be able to move forward, here is the link to the forum post for future Sean :
https://forum.freecodecamp.org/t/advanced-node-and-express-set-up-a-template-engine/757490
FIX :
'F11' to check console, run tests, found the errors, searched them up, and voila
'npm install cors' 
'const cors = require('cors');
app.use(cors());' 
That's it, 2 days of work to add 2 lines of code. Tests back, back on track. 

Use a Template Engine's Powers ===============================================================================================================================================================
One of the greatest features of using a template engine is being able to pass variables from the server to the template file before rendering it to HTML.
In your Pug file, you're able to use a variable by referencing the variable name as #{variable_name} inline with other text on an element or by 
  using an equal sign on the element without a space such as p=variable_name which assigns the variable's value to the p element's text.
Pug is all about using whitespace and tabs to show nested elements and cutting down on the amount of code needed to make a beautiful site.
Take the following Pug code for example:
head
  script(type='text/javascript').
    if (foo) bar(1 + 5);
body
  if youAreUsingPug
      p You are amazing
    else
      p Get on it!
The above yields the following HTML:

<head>
  <script type="text/javascript">
    if (foo) bar(1 + 5);
  </script>
</head>
<body>
  <p>You are amazing</p>
</body>
Your index.pug file included in your project, uses the variables title and message.
Pass those from your server to the Pug file by adding an object as a second argument to your res.render call with the variables and their values. 
  Give the title a value of Hello and message a value of Please log in.
It should look like :
res.render('index', { title: 'Hello', message: 'Please log in' });
Now refresh your page, and you should see those values rendered in your view in the correct spot as laid out in your index.pug file!
app.route('/').get((req, res) => {
  res.render('index', { title: 'Hello', message: 'Please log in' });
});

Set up Passport =============================================================================================================================================================================
It's time to set up Passport so you can finally start allowing a user to register or log in to an account. In addition to Passport, you will use Express-session to handle sessions.
Express-session has a ton of advanced features you can use, but for now you are just going to use the basics. Using this middleware saves the session id as a cookie in the client, 
  and allows us to access the session data using that id on the server. This way, you keep personal account information out of the cookie used by the client to tell to your server
  clients are authenticated and keep the key to access the data stored on the server.
passport@~0.4.1 and express-session@~1.17.1 are already installed, and are both listed as dependencies in your package.json file.
You will need to set up the session settings and initialize Passport. First, create the variables session and passport to require express-session and passport respectively.
Then, set up your Express app to use the session by defining the following options:
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: true,
  saveUninitialized: true,
  cookie: { secure: false }
}));
Be sure to add SESSION_SECRET to your .env file, and give it a random value. This is used to compute the hash used to encrypt your cookie!
After you do all that, tell your express app to use passport.initialize() and passport.session().
# You had to create a new '.env' file and add a line with 'SESSION_SECRET=....'

Serialization of a User Object ===============================================================================================================================================================
Serialization and deserialization are important concepts in regard to authentication.
  To serialize an object means to convert its contents into a small key that can then be deserialized into the original object.
  This is what allows us to know who has communicated with the server without having to send the authentication data, like the username and password, at each request for a new page.
To set this up properly, you need to have a serialize function and a deserialize function. In Passport, these can be created with:
passport.serializeUser(cb);
passport.deserializeUser(cb);
The callback function passed to serializeUser is called with two arguments: the full user object, and a callback used by passport.

The callback expects two arguments: An error, if any, and a unique key to identify the user that should be returned in the callback. 
  You will use the user's _id in the object. This is guaranteed to be unique, as it is generated by MongoDB.
Similarly, deserializeUser is called with two arguments: the unique key, and a callback function.
This callback expects two arguments: An error, if any, and the full user object. To get the full user object, make a query search for a Mongo _id, as shown below:
passport.serializeUser((user, done) => {
  done(null, user._id);
});
passport.deserializeUser((id, done) => {
  myDataBase.findOne({ _id: new ObjectID(id) }, (err, doc) => {
    done(null, null);
  });
});
Add the two functions above to your server. The ObjectID class comes from the mongodb package. mongodb@~3.6.0 has already been added as a dependency. Declare this class with:
const { ObjectID } = require('mongodb');
The deserializeUser will throw an error until you set up the database connection. So, for now, comment out the myDatabase.findOne call, 
and just call done(null, null) in the deserializeUser callback function.

Implement the Serialization of a Passport User ==============================================================================================================================================
You are not loading an actual user object since the database is not set up. Connect to the database once, when you start the server, 
  and keep a persistent connection for the full life-cycle of the app. To do this, add your database's connection string
  (for example: mongodb+srv://<username>:<password>@cluster0-jvwxi.mongodb.net/?retryWrites=true&w=majority) to the environment variable MONGO_URI. This is used in the connection.js file.
If you are having issues setting up a free database on MongoDB Atlas, check out this tutorial.
Now you want to connect to your database, then start listening for requests. The purpose of this is to not allow requests before your database is connected or if there is a database error.
  To accomplish this, encompass your serialization and app routes in the following code:
myDB(async client => {
  const myDataBase = await client.db('database').collection('users');
  // Be sure to change the title
  app.route('/').get((req, res) => {
    // Change the response to render the Pug template
    res.render('index', {
      title: 'Connected to Database',
      message: 'Please login'
    });
  });
  // Serialization and deserialization here...
  // Be sure to add this...
}).catch(e => {
  app.route('/').get((req, res) => {
    res.render('index', { title: e, message: 'Unable to connect to database' });
  });
});
// app.listen out here...
Be sure to uncomment the myDataBase code in deserializeUser, and edit your done(null, null) to include the doc.
-Had to go to MongoDB, create a new account, DB/Cluster, and get a connection string, make sure .env is in .gitignore, and good to go

Authentication Strategies ===================================================================================================================================================================
A strategy is a way of authenticating a user. You can use a strategy for allowing users to authenticate based on locally saved information 
  (if you have them register first) or from a variety of providers such as Google or GitHub. For this project, we will use Passport middleware. 
  Passport provides a comprehensive set of strategies that support authentication using a username and password, GitHub, Google, and more.
passport-local@~1.0.0 has already been added as a dependency. Add it to your server as follows:
const LocalStrategy = require('passport-local');
Tell passport to use an instantiated LocalStrategy object with a few settings defined. Make sure this (as well as everything from this point on) is 
  encapsulated in the database connection since it relies on it!:
passport.use(new LocalStrategy((username, password, done) => {
  myDataBase.findOne({ username: username }, (err, user) => {
    console.log(`User ${username} attempted to log in.`);
    if (err) return done(err);
    if (!user) return done(null, false);
    if (password !== user.password) return done(null, false);
    return done(null, user);
  });
}));
This is defining the process to use when you try to authenticate someone locally. First, it tries to find a user in your database with the username entered. 
  Then, it checks for the password to match. Finally, if no errors have popped up that you checked for (e.g. an incorrect password), the user object is returned and they are authenticated.
Many strategies are set up using different settings. Generally, it is easy to set it up based on the README in that strategy's repository. 
  A good example of this is the GitHub strategy where you don't need to worry about a username or password because the user will be sent to GitHub's auth page to authenticate. 
  As long as they are logged in and agree then GitHub returns their profile for you to use.

How to Use Passport Strategies ===============================================================================================================================================================
In the index.pug file supplied, there is a login form. It is hidden because of the inline JavaScript if showLogin with the form indented after it.
In the res.render for that page, add a new variable to the object, showLogin: true. When you refresh your page, you should then see the form! 
  This form is set up to POST on /login. So, this is where you should set up to accept the POST request and authenticate the user.
For this challenge, you should add the route /login to accept a POST request. To authenticate on this route, you need to add a middleware to do so before then sending a response.
  This is done by just passing another argument with the middleware before with your response. The middleware to use is passport.authenticate('local').
passport.authenticate can also take some options as an argument such as { failureRedirect: '/' } which is incredibly useful, so be sure to add that in as well.
  Add a response after using the middleware (which will only be called if the authentication middleware passes) that redirects the user to /profile. 
  Add that route, as well, and make it render the view profile.pug.
If the authentication was successful, the user object will be saved in req.user.
At this point, if you enter a username and password in the form, it should redirect to the home page /, and the console of your server should display 
  'User {USERNAME} attempted to log in.', since we currently cannot login a user who isn't registered.

Create New Middleware ========================================================================================================================================================================


























































