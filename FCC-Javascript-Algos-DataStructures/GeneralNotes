1.1 ================================================================================================================ Basic Javascript:
// This is an in-line comment.
/* This is a
multi-line comment */

We tell JavaScript to create or declare a variable by putting the keyword var in front of it, like so:
var ourName;
creates a variable called ourName. 
In JavaScript we end statements with semicolons.

In JavaScript, you can store a value in a variable with the assignment operator (=).
myVariable = 5;
This assigns the Number value 5 to myVariable.

It is common to initialize a variable to an initial value in the same line as it is declared.
var myVar = 0;
Creates a new variable called myVar and assigns it an initial value of 0.

When JavaScript variables are declared, they have an initial value of undefined. 
If you do a mathematical operation on an undefined variable your result will be NaN which means "Not a Number". 
If you concatenate a string with an undefined variable, you will get a string of undefined.

In JavaScript all variables and function names are case sensitive. This means that capitalization matters.
MYVAR is not the same as MyVar nor myvar. It is possible to have multiple distinct variables with the same name but different casing.
Best Practice : Write variable names in JavaScript in camelCase. In camelCase, multi-word variable names have the first word in 
lowercase and the first letter of each subsequent word is capitalized.
Examples:
var someVariable;
var anotherVariableName;
var thisVariableNameIsSoLong;
One of the biggest problems with declaring variables with the var keyword is that you can easily overwrite variable declarations

A keyword called let was introduced in ES6, a major update to JavaScript, to solve this potential issue with the var keyword. 
let camper = "David";
The error can be seen in your browser console.
So unlike var, when you use let, a variable with the same name can only be declared once.

The keyword let is not the only new way to declare variables. In ES6, you can also declare variables using the const keyword.
const has all the awesome features that let has, with the added bonus that variables declared using const are read-only.
They are a constant value, which means that once a variable is assigned with const, it cannot be reassigned:
const FAV_PET = "Cats";
FAV_PET = "Dogs";
The console will display an error due to reassigning the value of FAV_PET.
You should always name variables you don't want to reassign using the const keyword. 
Note: It is common for developers to use uppercase variable identifiers for immutable values and lowercase or camelCase for mutable values (objects and arrays).

Increment a Number with JavaScript
You can easily increment or add one to a variable with the ++ operator.
i++;
is the equivalent of
i = i + 1;
Note: The entire line becomes i++;, eliminating the need for the equal sign.

Decrement a Number with JavaScript
You can easily decrement or decrease a variable by one with the -- operator.
i--;
is the equivalent of
i = i - 1;

We can store decimal numbers in variables too. Decimal numbers are sometimes referred to as floating point numbers or floats.
Note: when you compute numbers, they are computed with finite precision. Operations using floating points may lead to different results than the desired outcome.

The remainder operator % gives the remainder of the division of two numbers.

myVar = myVar + 5;
to add 5 to myVar. Since this is such a common pattern, there are operators which do both a mathematical operation and assignment in one step.
myVar += 5;
Like the += operator, -= subtracts a number from a variable. *= for multiply. /= for divide.

When you are defining a string you must start and end with a single or double quote. What happens when you need a literal quote: " or ' inside of your string?
In JavaScript, you can escape a quote from considering it as an end of string quote by placing a backslash (\) in front of the quote.
const sampleStr = "Alan said, \"Peter is learning JavaScript\".";
This signals to JavaScript that the following quote is not the end of the string, but should instead appear inside the string. 
So if you were to print this to the console, you would get:
Alan said, "Peter is learning JavaScript".

String values in JavaScript may be written with single or double quotes, as long as you start and end with the same type of quote.
The reason why you might want to use one type of quote over the other is if you want to use both in a string. 
Note that the backslash itself must be escaped in order to display as a backslash.
\\	backslash
\n	newline
\b	backspace
You will need to use escape sequences to insert special characters correctly. 

You can find the length of a String value by writing .length after the string variable or string literal.
console.log("Alan Peter".length);

Bracket notation is a way to get a character at a specific index within a string.
Most modern programming languages, like JavaScript, don't start counting at 1 like humans do. They start at 0. This is referred to as Zero-based indexing.

In JavaScript, String values are immutable, which means that they cannot be altered once created.
you can get the value of the last letter of the string by using firstName[firstName.length - 1].
Example:
const firstName = "Ada";
const lastLetter = firstName[firstName.length - 1];
Use Bracket Notation to Find the Nth-to-Last Character in a String
You can use the same principle we just used to retrieve the last character in a string to retrieve the Nth-to-last character.
For example, you can get the value of the third-to-last letter of the const firstName = "Augusta" string by using firstName[firstName.length - 3]
Example:
const firstName = "Augusta";
const thirdToLastLetter = firstName[firstName.length - 3];

Store Multiple Values in one Variable using JavaScript Arrays
With JavaScript array variables, we can store several pieces of data in one place.
You start an array declaration with an opening square bracket, end it with a closing square bracket, and put a comma between each entry, like this:
const sandwich = ["peanut butter", "jelly", "bread"];
We can access the data inside arrays using indexes.
Array indexes are written in the same bracket notation that strings use, except that instead of specifying a character,
they are specifying an entry in the array. Like strings, arrays use zero-based indexing, so the first element in an array has an index of 0.
Example
const array = [50, 60, 70];
console.log(array[0]);
const data = array[1];
Unlike strings, the entries of arrays are mutable and can be changed freely, even if the array was declared with const.
Example
const ourArray = [50, 40, 30];
ourArray[0] = 15;

One way to think of a multi-dimensional array, is as an array of arrays. When you use brackets to access your array, 
the first set of brackets refers to the entries in the outermost (the first level) array, and each additional pair of brackets refers to the next 
level of entries inside.
Example
const arr = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9],
  [[10, 11, 12], 13, 14]
];
const subarray = arr[3];
const nestedSubarray = arr[3][0];
const element = arr[3][0][1];
In this example, subarray has the value [[10, 11, 12], 13, 14], nestedSubarray has the value [10, 11, 12], and element has the value 11 .
Note: There shouldn't be any spaces between the array name and the square brackets, like array [0][0] and even this array [0] [0] is not allowed. 

An easy way to append data to the end of an array is via the push() method.
The push() method takes one or more arguments and appends them to the end of the array, in the order in which they appear. 
It returns the new length of the array.
Examples:
const arr1 = [1, 2, 3];
arr1.push(4, 5);

Another way to change the data in an array is with the .pop() function.
.pop() is used to pop a value off of the end of an array. We can store this popped off value by assigning it to a variable. 
In other words, .pop() removes the last element from an array and returns that element.
Any type of entry can be popped off of an array - numbers, strings, even nested arrays.
const threeArr = [1, 4, 6];
const oneDown = threeArr.pop();
Manipulate Arrays With shift Method
pop() always removes the last element of an array. What if you want to remove the first?
That's where .shift() comes in. It works just like .pop(), except it removes the first element instead of the last.

Not only can you shift elements off of the beginning of an array, you can also unshift elements to the beginning of an array i.e. add elements in front of the array.
.unshift() works exactly like .push(), but instead of adding the element at the end of the array, unshift() adds the element at the beginning of the array.
Example:
const ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();
ourArray.unshift("Happy");
After the shift, ourArray would have the value ["J", "cat"]. After the unshift, ourArray would have the value ["Happy", "J", "cat"].

In JavaScript, we can divide up our code into reusable parts called functions.
Here's an example of a function:
function functionName() {
  console.log("Hello World");
}
You can call or invoke this function by using its name followed by parentheses, like this: functionName(); 

Parameters are variables that act as placeholders for the values that are to be input to a function when it is called. When a function is defined,
it is typically defined along with one or more parameters. The actual values that are input (or "passed") into a function when it is called are known as arguments.
Here is a function with two parameters, param1 and param2:
function testFun(param1, param2) {
  console.log(param1, param2);
}
Then we can call testFun like this: testFun("Hello", "World");. We have passed two string arguments, Hello and World. 

Return a Value from a Function with Return
We can pass values into a function with arguments. You can use a return statement to send a value back out of a function.
Example
function plusThree(num) {
  return num + 3;
}
const answer = plusThree(5);

In JavaScript, scope refers to the visibility of variables. Variables which are defined outside of a function block have Global scope. 
This means, they can be seen everywhere in your JavaScript code.
Variables which are declared without the let or const keywords are automatically created in the global scope. 
This can create unintended consequences elsewhere in your code or when running a function again. You should always declare your variables with let or const.
Variables which are declared within a function, as well as the function parameters, have local scope. That means they are only visible within that function.

In Computer Science a queue is an abstract Data Structure where items are kept in order. 
New items can be added at the back of the queue and old items are taken off from the front of the queue.

Another data type is the Boolean. Booleans may only be one of two values: true or false. 
They are basically little on-off switches, where true is on and false is off. These two states are mutually exclusive.

Use Conditional Logic with If Statements
if statements are used to make decisions in code. The keyword if tells JavaScript to execute the code in the curly braces under certain conditions,
defined in the parentheses. These conditions are known as Boolean conditions and they may only be true or false.
When the condition evaluates to true, the program executes the statement inside the curly braces. When the Boolean condition evaluates to false, 
the statement inside the curly braces will not execute.
Pseudocode
if (condition is true) {
  statement is executed
}
Example
function test(myCondition) {
  if (myCondition) {
    return "It was true";
  }
  return "It was false";
}
test(true);
test(false);

Comparison with the Equality Operator
There are many comparison operators in JavaScript. All of these operators return a boolean true or false value.
The most basic operator is the equality operator ==. The equality operator compares two values and returns true if they're equivalent or false if they are not.
Note that equality is different from assignment (=), which assigns the value on the right of the operator to a variable on the left.
function equalityTest(myVal) {
  if (myVal == 10) {
    return "Equal";
  }
  return "Not Equal";
}
If myVal is equal to 10, the equality operator returns true, so the code in the curly braces will execute, and the function will return Equal. 
Otherwise, the function will return Not Equal. In order for JavaScript to compare two different data types (for example, numbers and strings),
it must convert one type to another. This is known as Type Coercion. Once it does, however, it can compare terms as follows:

Comparison with the Strict Equality Operator
Strict equality (===) is the counterpart to the equality operator (==). However, unlike the equality operator,
which attempts to convert both values being compared to a common type, the strict equality operator does not perform a type conversion.
If the values being compared have different types, they are considered unequal, and the strict equality operator will return false.
Examples
3 ===  3  // true
3 === '3' // false
In the second example, 3 is a Number type and '3' is a String type.

Note: In JavaScript, you can determine the type of a variable or a value with the typeof operator, as follows:
typeof 3
typeof '3'

The strict inequality operator (!==) is the logical opposite of the strict equality operator. It means "Strictly Not Equal" and 
returns false where strict equality would return true and vice versa. The strict inequality operator will not convert data types.
Examples
3 !==  3  // false
3 !== '3' // true
4 !==  3  // true

The greater than operator (>) compares the values of two numbers. If the number to the left is greater than the number to the right, it returns true. 
The greater than or equal to operator (>=) compares the values of two numbers. If the number to the left is greater than or equal to the number to the right,
it returns true. Otherwise, it returns false.

Sometimes you will need to test more than one thing at a time. The logical and operator (&&) returns true if and only if the operands to the left and right
of it are true.
The same effect could be achieved by nesting an if statement inside another if.

Comparisons with the Logical Or Operator
The logical or operator (||) returns true if either of the operands is true. Otherwise, it returns false.
The logical or operator is composed of two pipe symbols: (||). This can typically be found between your Backspace and Enter keys.

Else Statements
When a condition for an if statement is true, the block of code following it is executed. What about when that condition is false? Normally nothing would happen. 
With an else statement, an alternate block of code can be executed.
if (num > 10) {
  return "Bigger than 10";
} else {
  return "10 or Less";
}

Else If Statements
If you have multiple conditions that need to be addressed, you can chain if statements together with else if statements.
if (num > 15) {
  return "Bigger than 15";
} else if (num < 5) {
  return "Smaller than 5";
} else {
  return "Between 5 and 15";
}

Logical Order in If Else Statements
Order is important in if, else if statements.
The function is executed from top to bottom so you will want to be careful of what statement comes first.
Take these two functions as an example.
Here's the first:
function foo(x) {
  if (x < 1) {
    return "Less than one";
  } else if (x < 2) {
    return "Less than two";
  } else {
    return "Greater than or equal to two";
  }
}
And the second just switches the order of the statements:
function bar(x) {
  if (x < 2) {
    return "Less than two";
  } else if (x < 1) {
    return "Less than one";
  } else {
    return "Greater than or equal to two";
  }
}
While these two functions look nearly identical if we pass a number to both we get different outputs.
foo(0)
bar(0)
foo(0) will return the string Less than one, and bar(0) will return the string Less than two.
Chaining If Else Statements : if/else statements can be chained together for complex logic.

Selecting from Many Options with Switch Statements
If you need to match one value against many options, you can use a switch statement.
A switch statement compares the value to the case statements which define various possible values.
Any valid JavaScript statements can be executed inside a case block and will run from the first matched case value until a break is encountered.
Here is an example of a switch statement:
switch (fruit) {
  case "apple":
    console.log("The fruit is an apple");
    break;
  case "orange":
    console.log("The fruit is an orange");
    break;
}
Adding a Default Option in Switch Statements
In a switch statement you may not be able to specify all possible values as case statements. 
Instead, you can add the default statement which will be executed if no matching case statements are found. 
Think of it like the final else statement in an if/else chain.
A default statement should be the last case.
switch (num) {
  case value1:
    statement1;
    break;
  case value2:
    statement2;
    break;
...
  default:
    defaultStatement;
    break;
}
If the break statement is omitted from a switch statement's case, the following case statement(s) are executed until a break is encountered. 
If you have many options to choose from, a switch statement can be easier to write than many chained if/else if statements. The following:
if (val === 1) {
  answer = "a";
} else if (val === 2) {
  answer = "b";
} else {
  answer = "c";
}
can be replaced with:
switch (val) {
  case 1:
    answer = "a";
    break;
  case 2:
    answer = "b";
    break;
  default:
    answer = "c";
}

When a return statement is reached, the execution of the current function stops and control returns to the calling location.
Example
function myFun() {
  console.log("Hello");
  return "World";
  console.log("byebye")
}
myFun();
The above will display the string Hello in the console, and return the string World. The string byebye will never display in the console,
because the function exits at the return statement.

In the casino game Blackjack, a player can determine whether they have an advantage on the next hand over the house by keeping track of the 
relative number of high and low cards remaining in the deck. This is called Card Counting.
Having more high cards remaining in the deck favors the player. Each card is assigned a value according to the table below. 
When the count is positive, the player should bet high. When the count is zero or negative, the player should bet low.
Count Change	Cards
+1	2, 3, 4, 5, 6
0	7, 8, 9
-1	10, 'J', 'Q', 'K', 'A'
You will write a card counting function. It will receive a card parameter, which can be a number or a string,
and increment or decrement the global count variable according to the card's value (see table).
The function will then return a string with the current count and the string Bet if the count is positive, 
or Hold if the count is zero or negative. The current count and the player's decision (Bet or Hold) should be separated by a single space.
Example Outputs: -3 Hold or 5 Bet
Hint
Do NOT reset count to 0 when value is 7, 8, or 9.
Do NOT return an array.
Do NOT include quotes (single or double) in the output.
var count = 0;
function cc(card) {
  switch(card) {
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      count++;
      break;
    case 10:
    case 'J':
    case 'Q':
    case 'K':
    case 'A':
      count--;
  }
  if(count > 0) {
    return count + " Bet";
  } else {
    return count + " Hold";
  }
}

You may have heard the term object before.
Objects are similar to arrays, except that instead of using indexes to access and modify their data, 
you access the data in objects through what are called properties.
Objects are useful for storing data in a structured way, and can represent real world objects, like a cat.
Here's a sample cat object:
const cat = {
  "name": "Whiskers",
  "legs": 4,
  "tails": 1,
  "enemies": ["Water", "Dogs"]
};

There are two ways to access the properties of an object: dot notation (.) and bracket notation ([]), similar to an array.
Dot notation is what you use when you know the name of the property you're trying to access ahead of time.
Here is a sample of using dot notation (.) to read an object's property:
const myObj = {
  prop1: "val1",
  prop2: "val2"
};
const prop1val = myObj.prop1;
const prop2val = myObj.prop2;

Accessing Object Properties with Bracket Notation
The second way to access the properties of an object is bracket notation ([]). 
If the property of the object you are trying to access has a space in its name, you will need to use bracket notation.
However, you can still use bracket notation on object properties without spaces.
Here is a sample of using bracket notation to read an object's property:
const myObj = {
  "Space Name": "Kirk",
  "More Space": "Spock",
  "NoSpace": "USS Enterprise"
};
myObj["Space Name"];
myObj['More Space'];
myObj["NoSpace"];

Accessing Object Properties with Variables
Another use of bracket notation on objects is to access a property which is stored as the value of a variable. 
This can be very useful for iterating through an object's properties or when accessing a lookup table.
Here is an example of using a variable to access a property:
const dogs = {
  Fido: "Mutt",
  Hunter: "Doberman",
  Snoopie: "Beagle"
};
const myDog = "Hunter";
const myBreed = dogs[myDog];
console.log(myBreed);
The string Doberman would be displayed in the console.



































