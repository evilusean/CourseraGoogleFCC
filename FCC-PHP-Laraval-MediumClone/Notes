Start : 28 August 2025

0:00:00 - Intro & Demo ========================================================================================================================================================================
https://medium.com/ #cloned website
Course teaches Basic Setup, Advanced Features : User Following, Post Management, Routing, Authentication, Database Operations, Blade Templating
You can see when the posts are published, when, by whom, likes, estimated read time, date published, category, filter by categories, search by user posts/profiles, followers  
create post requires : an image, title, category, content, publish date
profile page : change avatar, username, email, bio, password

0:05:35 - Setup Environment & Create Project ==================================================================================================================================================
Setup Environment - Laravel Herd (NGINX, PHP 8.4, MySQL, Redis) Only for windows and mac : 
https://herd.laravel.com/windows
Herd downloads the latest version of PHP-Laravel, NodeJS, NPM, NVM(node version manager), NGINX
When you open herd, it brings you to a dashboard to view your active services : open sites, general overview, paths, PHP versions, Node versions, 
Create a new project in herd from the dashboard -> 'open sites' -> '+Add'
  You can choose to use either React, Vue, or Livewiere for your new project, Name it, and that's it
Testing Frameworks : Pest Vs PHPUnit
For Laravel development on Arch Linux, users typically opt for alternative solutions such as:
Laravel Homestead:
A pre-packaged Vagrant box providing a complete development environment with PHP, Nginx, databases, and other services within a virtual machine.
https://laravel.com/docs/12.x/homestead
https://github.com/laravel/homestead
Laravel Homestead is an official, pre-packaged Vagrant box designed to provide a convenient and consistent development environment for Laravel applications. 
  It eliminates the need to manually install and configure server software like PHP, Nginx, MySQL, and other tools directly on your local machine.
Arch Linux Homestead Install :
sudo pacman -S vagrant 
sudo pacman -S virtualbox
git clone https://github.com/laravel/homestead.git ~/.local/share/homestead
cd ~/.local/share/homestead
git checkout release
bash init.sh
Configure Homestead.yaml: Open the generated ~/.local/share/homestead/Homestead.yaml file and configure it to your needs. 
  This includes setting the provider to virtualbox and mapping your project directories
Add a hosts file entry: Edit your /etc/hosts file with sudo and add an entry that maps your site's domain to the Homestead IP address (e.g., 192.168.10.10).
Installing Laravel Homestead on Arch Linux involves a few key steps. Since Homestead is a pre-configured Vagrant box, 
  you'll first need to install Vagrant and a virtualization provider like VirtualBox.
Open the generated ~/.local/share/homestead/Homestead.yaml file and configure it to your needs. This includes setting the provider to virtualbox and mapping your project directories.
YAML
provider: virtualbox
folders:
    - map: ~/Projects/MyProject
      to: /home/vagrant/MyProject
sites:
    - map: myproject.test
      to: /home/vagrant/MyProject/public
Add a hosts file entry:
Edit your /etc/hosts file with sudo and add an entry that maps your site's domain to the Homestead IP address (e.g., 192.168.10.10).
sudo nano /etc/hosts
# Add this line to the end of the file
192.168.10.10 myproject.test
Launching Homestead :
After all the configurations are complete, you can launch your virtual machine.
Navigate to the Homestead directory:
cd ~/.local/share/homestead
Start the virtual machine:
vagrant up # The first time you run this, Vagrant will download the pre-packaged Laravel Homestead box, which may take some time.
Access the VM: Once it's up, you can SSH into the virtual machine.
vagrant ssh
Manual setup:
Installing and configuring PHP, Nginx (or Apache), Composer, and any required databases (like MySQL or PostgreSQL) directly on the Arch Linux system.
Docker:
Utilizing Docker containers to create isolated and portable development environments for Laravel projects.
Therefore, while Laravel Herd is a powerful tool for its intended platforms, it cannot be directly installed or used on Arch Linux. 
  Users on Arch Linux should explore the alternative methods mentioned above for setting up their Laravel development environment.
Arch Linux Install (with SQLite) :
sudo pacman -Syu #update system, reboot
sudo pacman -S php php-fpm php-gd php-intl #install all php prerequisites
sudo pacman -S composer #install composer
sudo pacman -S php-sqlite #project will use sqlite
sudo nano /etc/php/php.ini # After installation, you need to enable the extension in your php.ini file. 
# Find the lines for the SQLite extensions and uncomment them by removing the semicolon ; at the beginning of each line. ';extension=pdo_sqlite' ';extension=sqlite3' 
sudo systemctl restart php-fpm #Restart the PHP-FPM service for the changes to take effect.
composer global require laravel/installer # Use Composer to install the Laravel installer globally.
#Add the Composer vendor bin directory to your system's PATH. This allows you to run the laravel command from any directory. The path is typically ~/.config/composer/vendor/bin on Arch Linux.
nano ~/.bashrc # Add the following line to the end of the file: 'export PATH="$PATH:$HOME/.config/composer/vendor/bin"'
source ~/.bashrc #resource, so you can use 'laravel' in terminal anywhere
laravel new your-project-name # will allow you to now create a new project 
laravel new FCC-MediumClone # new project, options : No Toolkit(react, etc), SQLite, NPM install, npm run build 
ERROR : Node is outdated, need version > 20, currently on 16 (did a 'sudo pacmna -Syu' yesterday so idk, need to fix)
https://github.com/nvm-sh/nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash #install script for NVM
yay -s nvm # idk which one worked
nvm ls-remote --lts # this was the fix, I installed version 20 globally, but my project was running 16(?) so I had to run these commands in the IDE terminal
nvm install <version_number>
nvm alias default <version_number>
Finally got everything working, took a day just to setup environment, 
VSCode vs PHPStorm - He's going over the IDE's - He reccomends PHP Storm, paid app, too poor, maybe future Sean might want. 
https://www.jetbrains.com/phpstorm/ 
VSCode Extensions : 'PHP - Devsense'(Has PHP syntax highlighting, autocomplete, etc) 'Laravel - Laravel' (Official VSCode Extension for Laravel) 
https://marketplace.visualstudio.com/items?itemName=enkia.tokyo-night 
https://marketplace.visualstudio.com/items?itemName=AtomMaterial.a-file-icon-vscode
'npm install' #the drill
'composer run dev' # how to start the server on linux
  This will not work on windows without editing the 'php.ini' file, since I will never use windows again, I never have to worry about this 'EGPCS' -> 'GCPS'
  Vite server runs with it, 
'npm run dev' # for windows and mac, linux should user 'composer run dev'

0:15:03 - Explore Directory Structure ======================================================================================================================================================
'app' folder = contains 'Http' (Controller.php) 
  'Models' (User.php) 
  'Providers' (AppServiceProvider.php)
'bootstrap' folder = contains 
  'cache' 
  'app.php' (this is the main file which initializes the application, confirguration with routing, 'create' method) 
  'providers.php'
'config' folder = contains every file needed for configuration
'database' = contains 'factories' (UserFactory.php = defines each field when new data is input, can also create unique dummy data)
  'migrations' (contains 3 migrations to begin with, a migration is a file which contains the DB schema change, instead of doing it manually use a migration, commit and push)
  'seeders' (DatabaseSeeder.php)
  'database.sqlite' (main file for tables/data)
'seeders' folder = contains 'DatabaseSeeder.php' (creates data in database)
'public' folder = contains all web accesible files, like 'favicon', 'robots.txt'
  'index.php' (the entry script, everything starts from index.php, whenever you access the app in the browser, everything get's accessed from index.php, loads packages, 
  uses 'bootstrap/app.php' to create the app
'resources' folder = contains 'css' (app.css)
  'js' (app.js, bootstrap.js)
  'views' (welcome-blade.php)
'routes' folder 
  'console.php' (for console comments)
  'web.php' (where you define all of the routes that you access in the browser)
'storage' folder 
  'app' folder ('private' = contains user uploaded data, 'public' = contains data)
  'framework forlder' ('cache' 'sessions' 'testing' 'views' = framework generated data)
  'logs' folder 
'tests' folder = contains tests (Pest.php, TestCase.php)
  'Feature'
  'Unit'
'vendor' folder = contains all the third party packages
'.env' = main configuration file with credentials, API keys, etc (other configs found in the 'config' folder)
'.env.example' = example env
'artisan' = important file, similar to 'public/index.php' file, requires '/vendor/autoload.php' and '/bootstrap/app.php' -> 'handleCommand(new ArgvInput)' method to start app
  Artisan is the main command line interface that you use to interact with your php project
'composer.json' = dependancies 
'composer.lock' = dependancies
'package.json' = npm dependancies
'vite.config.js' = vite server config (php runs a vite server)

0:21:36 - Introducing Artisan ==============================================================================================================================================================
ERROR : Did a 'yay -Syu' to update my VSCode, and it broke my hyprland setup, spent the last few hours trying to fix, missing my top bar, reinstalling the dot-files to fix
'yay -S --rebuild quickshell' # It doesn't use waybar, it uses quickshell, this at least get's it to load the search feature
'yay -S --rebuild google-breakpad-git' # in order to rebuild quickshell, I needed to rebuild this thing
everything still 'works' all the keybindings, I just have no UI/top bar, can't see the time either - Future Sean Problem
'php artisan list' # shows all the artisan commands, listed below :
Usage:
  command [options] [arguments]
Options:
  -h, --help            Display help for the given command. When no command is given display help for the list command
      --silent          Do not output any message
  -q, --quiet           Only errors are displayed. All other output is suppressed
  -V, --version         Display this application version
      --ansi|--no-ansi  Force (or disable --no-ansi) ANSI output
  -n, --no-interaction  Do not ask any interactive question
      --env[=ENV]       The environment the command should run under
  -v|vv|vvv, --verbose  Increase the verbosity of messages: 1 for normal output, 2 for more verbose output and 3 for debug
Available commands:
  about                     Display basic information about your application
  clear-compiled            Remove the compiled class file
  completion                Dump the shell completion script
  db                        Start a new database CLI session
  docs                      Access the Laravel documentation
  down                      Put the application into maintenance / demo mode
  env                       Display the current framework environment
  help                      Display help for a command
  inspire                   Display an inspiring quote
  list                      List commands
  migrate                   Run the database migrations
  optimize                  Cache framework bootstrap, configuration, and metadata to increase performance
  pail                      Tails the application logs.
  serve                     Serve the application on the PHP development server
  test                      Run the application tests
  tinker                    Interact with your application
  up                        Bring the application out of maintenance mode
 auth
  auth:clear-resets         Flush expired password reset tokens
 cache
  cache:clear               Flush the application cache
  cache:forget              Remove an item from the cache
  cache:prune-stale-tags    Prune stale cache tags from the cache (Redis only)
 channel
  channel:list              List all registered private broadcast channels
 config
  config:cache              Create a cache file for faster configuration loading
  config:clear              Remove the configuration cache file
  config:publish            Publish configuration files to your application
  config:show               Display all of the values for a given configuration file or key
 db
  db:monitor                Monitor the number of connections on the specified database
  db:seed                   Seed the database with records
  db:show                   Display information about the given database
  db:table                  Display information about the given database table
  db:wipe                   Drop all tables, views, and types
 env
  env:decrypt               Decrypt an environment file
  env:encrypt               Encrypt an environment file
 event
  event:cache               Discover and cache the application's events and listeners
  event:clear               Clear all cached events and listeners
  event:list                List the application's events and listeners
 install
  install:api               Create an API routes file and install Laravel Sanctum or Laravel Passport
  install:broadcasting      Create a broadcasting channel routes file
 key
  key:generate              Set the application key
 lang
  lang:publish              Publish all language files that are available for customization
 make
  make:cache-table          [cache:table] Create a migration for the cache database table
  make:cast                 Create a new custom Eloquent cast class
  make:channel              Create a new channel class
  make:class                Create a new class
  make:command              Create a new Artisan command
  make:component            Create a new view component class
  make:config               [config:make] Create a new configuration file
  make:controller           Create a new controller class
  make:enum                 Create a new enum
  make:event                Create a new event class
  make:exception            Create a new custom exception class
  make:factory              Create a new model factory
  make:interface            Create a new interface
  make:job                  Create a new job class
  make:job-middleware       Create a new job middleware class
  make:listener             Create a new event listener class
  make:mail                 Create a new email class
  make:middleware           Create a new HTTP middleware class
  make:migration            Create a new migration file
  make:model                Create a new Eloquent model class
  make:notification         Create a new notification class
  make:notifications-table  [notifications:table] Create a migration for the notifications table
  make:observer             Create a new observer class
  make:policy               Create a new policy class
  make:provider             Create a new service provider class
  make:queue-batches-table  [queue:batches-table] Create a migration for the batches database table
  make:queue-failed-table   [queue:failed-table] Create a migration for the failed queue jobs database table
  make:queue-table          [queue:table] Create a migration for the queue jobs database table
  make:request              Create a new form request class
  make:resource             Create a new resource
  make:rule                 Create a new validation rule
  make:scope                Create a new scope class
  make:seeder               Create a new seeder class
  make:session-table        [session:table] Create a migration for the session database table
  make:test                 Create a new test class
  make:trait                Create a new trait
  make:view                 Create a new view
 migrate
  migrate:fresh             Drop all tables and re-run all migrations
  migrate:install           Create the migration repository
  migrate:refresh           Reset and re-run all migrations
  migrate:reset             Rollback all database migrations
  migrate:rollback          Rollback the last database migration
  migrate:status            Show the status of each migration
 model
  model:prune               Prune models that are no longer needed
  model:show                Show information about an Eloquent model
 optimize
  optimize:clear            Remove the cached bootstrap files
 package
  package:discover          Rebuild the cached package manifest
 pest
  pest:dataset              Create a new dataset file
  pest:test                 Create a new test file
 queue
  queue:clear               Delete all of the jobs from the specified queue
  queue:failed              List all of the failed queue jobs
  queue:flush               Flush all of the failed queue jobs
  queue:forget              Delete a failed queue job
  queue:listen              Listen to a given queue
  queue:monitor             Monitor the size of the specified queues
  queue:prune-batches       Prune stale entries from the batches database
  queue:prune-failed        Prune stale entries from the failed jobs table
  queue:restart             Restart queue worker daemons after their current job
  queue:retry               Retry a failed queue job
  queue:retry-batch         Retry the failed jobs for a batch
  queue:work                Start processing jobs on the queue as a daemon
 route
  route:cache               Create a route cache file for faster route registration
  route:clear               Remove the route cache file
  route:list                List all registered routes
 sail
  sail:add                  Add a service to an existing Sail installation
  sail:install              Install Laravel Sail's default Docker Compose file
  sail:publish              Publish the Laravel Sail Docker files
 schedule
  schedule:clear-cache      Delete the cached mutex files created by scheduler
  schedule:interrupt        Interrupt the current schedule run
  schedule:list             List all scheduled tasks
  schedule:run              Run the scheduled commands
  schedule:test             Run a scheduled command
  schedule:work             Start the schedule worker
 schema
  schema:dump               Dump the given database schema
 storage
  storage:link              Create the symbolic links configured for the application
  storage:unlink            Delete existing symbolic links configured for the application
 stub
  stub:publish              Publish all stubs that are available for customization
 vendor
  vendor:publish            Publish any publishable assets from vendor packages
 view
  view:cache                Compile all of the application's Blade templates
  view:clear                Clear all compiled view files
'php artisan about' # tells you about your php/laravel/artisan versions, timezones, confs, caches, drivers, etc
'php artisan make --help' # --help flag tells you what a command does, and shows you all the commands that can be used with it
Artisan is your main tool for Laravel-PHP, you can use it to create files, create caches, etc

0:23:22 - Laravel Configuration ============================================================================================================================================================= 
'.env' # contains your main laravel configurations and not just your API keys in PHP-Laravel
'config' folder has all the other configurations 'app.php' 'auth.php' 'cache.php' 'database.php' ..... etc, each one corresponds with the config for it's name
if you aren't going to make any changes to the 'config' folder files, you can delete them, the config files already exist in laravel core, and if they aren't there,
  the framework will use the laravel core versions, if you only modify one part of one 'config -> _.php' file you can delete everything else in that file aswell, and laravel will use default
'php artisan config:publish' # will allow you to use your new config files, if the file isn't in the 'config' folder, it will create it and you can edit it 

0:26:27 - Create Basic Route ================================================================================================================================================================== 
'routes -> web.php' 
<?php //this is a opening tag for PHP. It is a special marker that tells the web server that the code that follows is to be interpreted as PHP and not as plain HTML.
// The 'Route' facade is a class provided by the framework (e.g., Laravel)
// that simplifies the process of defining application routes.
// The 'get' method registers a new route that responds only to
// HTTP GET requests. This is the most common type of request, used
// by web browsers to fetch a page.
// The first argument, '/hello', is the URI (Uniform Resource Identifier)
// that the application will listen for. When a user visits this path,
// the code inside the function is executed.
Route::get('/hello', function() {
    return 'Hello, World!';
    // This is an anonymous function (or closure) that acts as the
    // handler for the route. This function is executed when the
    // URI '/hello' is requested with a GET method.
    // The 'return' statement sends the specified value back as the
    // HTTP response. The framework automatically takes this plain string
    // and sends it to the user's web browser, which will then
    // display "Hello, World!" on the screen.
}); // will return 'Hello, World!' as plain text on the browser screen
// The 'Route' facade is used to register a new route for the application.
// The 'get' method specifies that this route should handle HTTP GET requests.
// The first argument, '/', is the URI. This is a special case that
// represents the root of the website (e.g., [your-website.com/](https://your-website.com/)).
Route::get('/', function () {
    return view('welcome'); // 'welcome' will automatically fetch 'welcome.blade.php' and you don't need to type out the entire folder structure and file name
    // This is the function that will be executed when a user visits
    // the root URL.
    // The 'return' statement sends the result of the 'view()' function
    // back to the user.
    // The 'view()' function is a helper function that tells the framework
    // to find and render an HTML file (called a "view").
    // The argument 'welcome' tells the framework to look for a file
    // named 'welcome.blade.php' (or similar) inside the 'resources/views'
    // directory. The content of that file will be rendered as the
    // final web page.
}); // will return a view instead of just plaintext, you can construct entire web pages as views in the file format '_.blade.php' 

0:28:01 - Registration & Login (Laravel Breeze) =============================================================================================================================================
'composer require laravel/breeze' # will require and install breeze package, which has everything you need for authentication : registration, login, email verification, password resets, etc
'php artisan breeze:install' # installs breeze into your project (select 'Blade with Alpine' so you don't introduce any new frameworks, 'No' darkmode, 'Pest' Tests) 
  #the above command will update composer.json, package.lock, add tonnes of files(scaffolding) for login, auth, etc, 
'composer run dev' # you will now see 2 new buttons at the top of your screen 'Login' 'Register', pretty cool, 2 commands to set up auth/login/registration/profile/etc
'views -> welcome.blade.php' will be updated with the new buttons, it literally does all the heavy lifting.... with 2 commands, I had to hook up nothing to the backend, 
  No email services, no databases, no third parties, no building authentication/login/email/etc pages, it just works... actually pretty cool.
'views -> dashboard.blade.php' # this is what shows when you have a succesful login
'views -> auth -> _.blade.php' # adds all the new files/views for your project, automatically, saving days of work, I can see why people like PHP now
  'login.blade.php' 'register.blade.php' 'confirm-password.blade.php' 'forgot-password.blade.php' 'reset-password.blade.php' 'verify-email.blade.php' 
'views -> components -> _.blade.php' # all components for auth were added here 'danger-button.blade.php' 'dropdown.blade.php' etc
'views -> layouts -> app.blade.php' # layout for authenticated users
'views -> layouts -> guest.blade.php' # this is the layout for unauthenticated users 
'views -> layouts -> navigation.blade.php' # navigation for authenticated users
'views -> partials -> edit.blade.php' # allows you to edit your user profile, split into 3 components, update password, profile and delete user form
# the reason why all this is so cool, is it does the heavy lifting for you, this would all take days to do manually, all you do is set up the scaffolding, and then make it look pretty
'routes -> auth.php' # added with the command, controllers(which do all of the requests like authentication, registration, posts, requests, gets, etc)
'routes -> web.php' # automatically updated with all the new routes, adds the routes from auth.php automatically added for 'view/get' 'update' 'delete'

0:33:31 - Email Verification ================================================================================================================================================================
I'm adding detailed comments for each controller, because I had no idea what was going on before, I actually want to learn PHP, so I might as well learn about this part now, for future Sean
https://github.com/evilusean/CourseraGoogleFCC/tree/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/app/Http/Controllers/Auth
A class in PHP is very similar to a class in Java. Both are core components of object-oriented programming (OOP).
What is a Class?
Think of a class as a blueprint or a template for creating things called objects. It defines a set of properties (variables) and methods (functions) that an object of that class will have.
For example, if you have a 'Car' class, the blueprint might define properties like 'color', 'make', and 'model', and methods like 'startEngine()' or 'accelerate()'.

    // This route handles displaying the registration form.
    // 'get' means it responds to a browser navigating to '/register'.
    // '[RegisteredUserController::class, 'create']' specifies that the 'create' method
    // on the 'RegisteredUserController' class will handle this request.
    // '->name('register')' gives this route a unique, human-readable name. This is very
    // useful for generating URLs in your code (e.g., redirecting to 'register').
    Route::get('register', [RegisteredUserController::class, 'create'])
        ->name('register');

// here is the 'create' function from 'app/Http/Controllers/Auth/RegisteredUserController.php' where the 'create' function lives :
// This line declares the class. 'extends Controller' means that 'RegisteredUserController'
// inherits all the methods and properties from Laravel's base 'Controller' class,
// giving it built-in functionality without having to write it from scratch.
class RegisteredUserController extends Controller
{
    /**
     * This is a "docblock" comment. It's a best practice to document what a method does.
     * It explains that this method's purpose is to "Display the registration view."
     */
    public function create(): View // The ': View' type hint indicates that this function will return a View object.
    {
        // This is the core difference. The 'view()' helper function is used to load and render a
        // Blade template file. It tells Laravel to look for the file located at
        // 'resources/views/auth/register.blade.php'.
        return view('auth.register');
    }

    /**
     * This docblock explains that this method handles the form submission
     * for a new user registration request.
     * The '@throws' line documents that this function might throw a 'ValidationException'
     * if the form data is invalid, which is handled automatically by Laravel.
     */
    public function store(Request $request): RedirectResponse
    {
        // The `$request->validate()` method is a critical step for security and data integrity.
        // It checks the incoming form data against a set of rules. If any rule fails,
        // Laravel automatically redirects the user back to the form with the validation errors.
        // The array syntax here is another way to list validation rules, which is often preferred
        // for readability when you have multiple rules.
        $request->validate([
            // This rule ensures the 'name' field is required, is a string, and has a maximum length.
            'name' => ['required', 'string', 'max:255'],

            // This rule ensures the 'email' is required, a string, converted to lowercase,
            // is a valid email format, has a max length, and is unique in the 'users' table.
            'email' => ['required', 'string', 'lowercase', 'email', 'max:255', 'unique:'.User::class],

            // This rule for 'password' is an array of rules.
            // - 'required': must be present.
            // - 'confirmed': automatically checks for a matching 'password_confirmation' field.
            // - 'Rules\Password::defaults()': loads a set of default security rules, like minimum length.
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // After validation passes, this line creates a new 'User' model instance
        // and saves it to the database in one step.
        // 'User::create()' is a powerful Eloquent ORM method.
        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            // The password MUST be hashed before storing it for security.
            // 'Hash::make()' uses a secure, one-way algorithm to encrypt the password.
            'password' => Hash::make($request->password),
        ]);

        // This line triggers a built-in Laravel 'Registered' event.
        // This allows other parts of the application to react to a new user registration.
        // A common use is to automatically send a 'Verify Email Address' notification to the user.
        event(new Registered($user));

        // The 'Auth' facade provides methods for handling user sessions.
        // 'Auth::login($user)' immediately logs the newly created user into the application.
        Auth::login($user);

        // This line returns a redirect response. The browser is instructed to go to a new URL.
        // 'route('dashboard', absolute: false)' is the best way to generate the URL. It
        // looks up the URL for the route named 'dashboard' instead of hardcoding a URL string.
        return redirect(route('dashboard', absolute: false));
    }
} // got AI to add detailed comments, breaking my own formatting rules by adding more than one new line per lesson, it's hard enough to read as is.
# used for logging you in, set up by breeze automatically, 
https://github.com/evilusean/CourseraGoogleFCC/blob/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/app/Http/Controllers/Auth/AuthenticatedSessionController.php
When setting up our account originally out of the box, we were able to create a new user without email verification, you need to enable this in 'app -> Models -> User.php'
change this line in 'User.php' = 'class User extends Authenticatable' -> 'class User extends Authenticatable implements MustVerifyEmail' 
  to add email verification, that's all you need to do, one line, amazing
'.env' go to 'MAIL_MAILER=log' # this shows us that our mail is added to log file 'storage -> logs -> laravel.log' - every email sent out will be stored here, 
  after checking the logs, you can see the verify email address link and click it from the log to verify an account (even if it's a fake email account) and use account
MailPit (free way to test your apps with email auth/registration) :
https://mailpit.axllent.org/
https://mailpit.axllent.org/docs/
https://mailpit.axllent.org/docs/install/
'yay -S mailpit-bin' #install on arch linux
after installing mailpit, type 'mailpit' in a terminal, it will give you 'http://localhost:8025/' that you can open in a browser to access the emails, now...
  to get emails sent to it instead of the log file go to '.env' and change 'MAIL_MAILER=log' -> 'MAIL_MAILER=smtp' and change 'MAIL_PORT=1025'

0:40:14 - Tinker ============================================================================================================================================================================
'php artisan tinker' # interactive readable print loop, write any valid laravel code and will read then give you the output
'User::get()' # 'User' here is the same as 'app -> Models -> User.php' and will select every user in that database 
[!] Aliasing 'User' to 'App\Models\User' for this Tinker session.
= Illuminate\Database\Eloquent\Collection {#1365
    all: [
      App\Models\User {#6071
        id: 1,
        name: "Test1",
        email: "test1@fakemail.com",
        email_verified_at: null,
        #password: "$2y$12$brMsTWqcWKNid/ash4H30uXdixdt4wFgtom6M5XE/G4EUxpsus02S",
        #remember_token: null,
        created_at: "2025-08-31 17:35:29",
        updated_at: "2025-08-31 17:35:29",
      },
      App\Models\User {#6072
        id: 2,
        name: "Test",
        email: "test2@email.com",
        email_verified_at: "2025-09-01 20:57:25",
        #password: "$2y$12$0NbjZxWQySPpe5pe9jIGOODmReDNyqYvPAFBFmWYBmoeJYlGyjzzi",
        #remember_token: null,
        created_at: "2025-09-01 20:55:43",
        updated_at: "2025-09-01 20:57:25",
      },
      App\Models\User {#6073
        id: 3,
        name: "Test3",
        email: "test3@email.com",
        email_verified_at: "2025-09-01 21:01:38",
        #password: "$2y$12$PkzF3n3eJQNhyCsD6SjZk.6PBw/WanjZzOVFfuQRBpAoEAYoSXS4K",
        #remember_token: null,
        created_at: "2025-09-01 21:01:26",
        updated_at: "2025-09-01 21:01:38",
      },
      App\Models\User {#6074
        id: 4,
        name: "Test4",
        email: "test4@email.com",
        email_verified_at: "2025-09-01 21:21:25",
        #password: "$2y$12$JoF7yvfSv5ryVpMV6FwQq.TdrmS/erwRafmknLkHMfpTzYC.5tADy",
        #remember_token: null,
        created_at: "2025-09-01 21:20:39",
        updated_at: "2025-09-01 21:21:25",
      },
    ],
  } # this is the return, for tinker command 'User::get', it has the name, hashed password, date created, verified, 
Whenever you add a new column into a User table, or new tables, 
$user = User::first() # will assign $user the first user in the table of 'User'
$user->name = 'SeanTest1' # assigns the name 'Test1' to '$user', and changes the name(only in the instance of tinker, it needs to be updated to the database
$user->save(); # will save the new name to the database
It's important to remember 'namespace' that get's called as a reference for each command written in php laravel tinker

0:44:02 - Models & Migrations ===============================================================================================================================================================
First he generated 2 models with migrations
'php artisan make:model --help' #Create a new Eloquent model class
'php artisan make:model [options] [--] <name>' #basic syntax for creating a new model
'php artisan make:model Category -m' # creates a new model named 'Category' and '-m' flag creates a migration file, 2 files and their new locations below:
# Model [app/Models/Category.php] created successfully.   # Migration [database/migrations/2025_09_01_220023_create_categories_table.php] created successfully.
Notice that the migration has a timestamp for when it was actually generated 
What is a Migration? A migration is a version control system for your database schema. Instead of manually creating or modifying tables in your database,
  you write a migration file that contains instructions for these changes. This allows you to track and manage changes to your database schema over time, 
  just as you would with application code. Each migration file has two key methods:
up(): Defines the changes to be applied, such as creating a new table, adding a column, or modifying a data type.
down(): Defines the "rollback" or reverse of the up() method, allowing you to undo the changes.
Using migrations ensures that your database structure is consistent across different environments (e.g., development, staging, and production) and 
  among all members of a development team. When a new team member joins, they can simply run a single command (php artisan migrate) to get their database schema 
  up to date with the latest version.
'php artisan make:model Post -m' # create 2 new files, a model 'Post' and a migration with a timestamp
'database -> migrations' # where you can find all the migrations sorted by timestamp, system migrations created by laravel start with '0001' as the timestamp 
migrations must be applied in a sequential order start from oldest to newest, a migration is a file that contains database schema changes
VERY common practice and always recomended to write migrations for your project (future Seans not problem), documentation of your schema, so if past sean does a mistake, future Sean can fix
whenever you push your project to production, you simply execute your migrations in sequential order, and the production schema will be the exact same as your local development
migrations have 2 main methods 'up()' and 'down()', whatever you put inside 'up()' should be done in reverse in 'down()'
public function down(): void
    {
        Schema::dropIfExists('categories');
    } # automatically generated by laravel to drop the table for 'down()'
'php artisan migrate' # creates the 2 tables based on the migrations we created, we added   2025_09_01_220023_create_categories_table  2025_09_01_220449_create_posts_table
https://github.com/evilusean/CourseraGoogleFCC/blob/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/database/migrations/2025_09_01_220023_create_categories_table.php
https://github.com/evilusean/CourseraGoogleFCC/blob/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/database/migrations/2025_09_01_220449_create_posts_table.php
You can see the added tables in the format below, we left links to the detailed comments for each one above, basically, each line creates a new column in the database :
public function up(): void
{
Schema::create('posts', function (Blueprint $table) {
$table->id();
$table->string('images')->nullable();
$table->string('title');
$table->string('slug')->unique();
$table->longText('content');
$table->foreignId('category_id')->constrained()->onDelete('cascade');
$table->foreignId('user_id')->constrained()->onDelete('cascade');
$table->timestamp('published_at')->nullable();
$table->timestamps();
});
}
'php artisan db:show' # will show information about the database, connection, host, port, schemas, tables, etc.
'php artisan tinker' '\App\Models\Category::get()' # will get all of the data from the newly created 'Category' table, since we couldn't alias, we explicitly told it to get the model

0:52:25 - Factories & Seeders ================================================================================================================================================================
'php artisan make:factory PostFactory' # creates a new factory named 'PostFactory' [database/factories/PostFactory.php]
'php artisan make:model Post -f' # will create a model, with the '-f' flag, it will also create a factory with it
'app -> Models -> Post.php' add the new factory to the 'Post.php' 'Post' class with the imported trait 'use HasFactory'
class Post extends Model
{
    use HasFactory; 
}
The purpose of the factory class is to generate definitions for each fields of the corresponding model or the DB table
You can use the 'fake()' function/package to generate fake data for your factory
'database -> factories -> PostFactory.php' 
public function definition(): array
    {
        $title = fake()->sentence();
        return [
            'image' => fake()-> imageUrl(),
            'title' => $title,
            'slug' => \Illuminate\Support\Str::slug($title),
            'content' => fake()->paragraphs(5),
            'category_id' => Category::inRandomOrder()->first()->id,
            'user_id' => 1,
            'published_at' => fake()->optional()->dateTime(),
        ];
    }
https://github.com/evilusean/CourseraGoogleFCC/blob/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/database/factories/PostFactory.php
# added detailed comments
ERROR : 'php artisan db:table' # wasn't working, had to edit 'sudo nvim /etc/php/php.ini' '/intl' to search, and uncomment the line ';extension=intl' and now it works 
'php --ini' # will show you where your configs are for php '/etc/php/php.ini'
'php artisan migrate:rollback --step=1' # how to roll back your migrations, only to the last one (step=1), to get back to where
'php artisan migrate' # will reapply the migrations that you just rolled back
the reason why he did this, was he changed the 'images' on 'posts' table to 'image', so you rollback, and then apply your changes
The purpose is to seed some data, create or update, to the database
'database -> seeder -> DatabaseSeeder.php' 
https://github.com/evilusean/CourseraGoogleFCC/blob/main/FCC-PHP-Laraval-MediumClone/FCC-MediumClone/database/seeders/DatabaseSeeder.php
How do you execute the database seeder to actually create the data? 2 ways : 1) During a migration execute the seeder, or seed the database manually
'php artisan migrate --seed' # add the '--seed' flag to add your seed data to the database
'php artisan db:seed' # will seed your database with your seeder files 
'php artisan make:seeder PostSeeder' # how to make a new sneeder : [database/seeders/PostSeeder.php] created successfully.  
The 'DatabaseSeeder.php' is the MAIN seeder, if you want to add other seeders onto it, you need to :
'$this->call([PostSeeder::class,]);' # add this to the end of 'DatabaseSeeder.php' to run 'PostSeeder.php' when you execute the seeding OR :
'php artisan db:seed --class=PostSeeder' # this is how you do it from the command line, seeding outside of the main 'DatabaseSeeder.php'
'php artisan tinker' -> '\App\Models\Post::get()' # how to check our newly seeded data, 100 randomized posts, pretty cool, starting to like php
'php artisan migrate:fresh --seed' # 'migrate:fresh' drops all the tables, and '--seed' flag uses the 'DatabaseSeeder.php' to seed the database

1:05:13 - Output Categories & Posts =========================================================================================================================================================
Flowbite (Tailwind CSS Components) : https://flowbite.com/
'views -> dashboard.blade.php' # copy and paste 'pills tabs' from flowbite, remove some old boilerplate
https://flowbite.com/docs/components/tabs/
'dashboard.blade.php' renders from 'routes -> web.php' # below will check if you are authenticated when going to the route '/dashboard' and then returns the view 'dashboard.blade.php'
Route::get('/dashboard', function () {
    return view('dashboard');
})->middleware(['auth', 'verified'])->name('dashboard');
'php artisan make:controller PostController --resource' # will make a new controller named 'PostController' the '--resource' flag will generate the controller with predefined methods
  'app -> Http -> Controllers -> 'PostController.php' # file will be generated here, if you don't use the '--resource' flag, it will be empty
  even with the '--resource' flag it still needs work, it generates it with 7 unfinished methods
'php artisan make:controller PostController --resource --model=Post' # will generate the PostController for the model 'Post.php', instead of asking for 'string $id' it will ask for a 
  'Post $post' instead, 
'routes -> web.php' also imports controllers for navigation, be sure to add your new one there after it is created 
Route::get('/dashboard', [PostController::class, 'index'])->middleware(['auth', 'verified'])->name('dashboard');
  # will import the postcontroller class, removed the old route, and receive the categories array from the 
public function index()
    {
        $categories = Category::get(); // will get all categories from the database (created by DatabaseSeeder.php array)
        //dump($categories); //dump will print all categories to the console
        //dd($categories); // dump and die, as soon as it prints the categories, the script stops here, it stops the execution
        return view('dashboard', ['categories'=> $categories]);
    }
the flowbite code we copied had slightly different tabs, tab 4 and 5 were unselectable (I think it does this to give you variety on pre-assembled components) so they were deleted
'Directives' are special keywords that are available inside blade templates which provide certain tasks, can be used for iteration, conditionals, etc. Here is one below :
                        @foreach ($categories as $category)
                        <li class="me-2">
                            <a href="#"
                                class="inline-block px-4 py-3 rounded-lg hover:text-gray-900 hover:bg-gray-100 dark:hover:bg-gray-800 dark:hover:text-white">
                                {{ $category->name }}
                            </a>
                        </li>
                        @endforeach
# notice the '@foreach ($categories as $category)' and '@endforeach' inbetween that is a directive that will print off the category name on a tab created for each name in the $categories
# also notice the {{ }} double curly braces to access the name property for each category object and use it for each new tab
// `Post::`: This is a static call to the `Post` Eloquent model. In Laravel, an Eloquent model
// corresponds to a database table, so `Post` represents the `posts` table.
$posts = Post::orderBy('created_at', 'DESC')->get();
// `orderBy('created_at', 'DESC')`: This is the method that orders the query results.
// - The first argument, `'created_at'`, specifies the column to sort by. Laravel automatically
//   creates and manages this timestamp column, which tracks when each post was created.
// - The second argument, `'DESC'`, specifies the sorting direction as "descending".
//   This means the posts will be returned with the most recently created one appearing first.
//   To get the posts from oldest to newest, you would use 'ASC' for ascending order.
// `get()`: This method executes the query and retrieves all the results. It returns the
// matched records as an Eloquent Collection, which is a powerful, array-like object
// in Laravel that provides many convenient methods for working with the results.
// The final result, `$posts`, will be a collection of `Post` model objects.
                @foreach ($posts as $post)
                    <div
                        class="flex bg-white border border-gray-200 rounded-lg shadow-sm dark:bg-gray-800 dark:border-gray-700 mb-8">
                        <div class="p-5 flex-1">
                            <a href="#">
                                <h5 class="mb-2 text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
                                    {{ $post->title }}
                                </h5>
                            </a>
                            <div class="mb-3 font-normal text-gray-700 dark:text-gray-400">
                                {{ Str::words($post->content, 15) }} # helper function to reduce the content to 15 words
                            </div>
                            <a href="#"
                                class="inline-flex items-center px-3 py-2 text-sm font-medium text-center text-white bg-blue-700 rounded-lg 
                                hover:bg-blue-800 focus:ring-4 focus:outline-none focus:ring-blue-300 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
                                Read more
                                <svg class="rtl:rotate-180 w-3.5 h-3.5 ms-2" aria-hidden="true"
                                    xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10">
                                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                                        stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9" />
                                </svg>
                            </a>
                        </div>
                        <a href="#">
                            <img class="rounded-r-lg w-48 h-48 object-cover" src="{{ $post->image }}" alt="" /> # dynamic images
                        </a>
                        </a>
                    </div>
                @endforeach
# again, notice the '@' for a new directive and the '{{ }}' curly braces for placing dynamic values from the DB, even for the <img src="{{ $post->image }}">

1:27:09 - Pagination ========================================================================================================================================================================
Our seeder creates 100 posts, so we are displaying 100 posts each time with our @foreach directive loop
'app -> Http -> Controllers -> Auth -> PostController.php' change from 'get()' to '$posts = Post::orderBy('created_at', 'DESC')->paginate(10);' where this will get 10 items per page
  one line of code to implement pagination, not even, one method/function. 2 lines of code to fully implement pagination, one for the controller and one for the blade.php
'dashboard.blade.php' make sure to add '{{ $posts->links() }} {{-- pagination links --}}' so you can scroll through each page 
In the url it will also display the page as a url parameter '?page=5', it just does it out of the box, don't have to code it. 
{{ $posts->onEachSide(2)->links() }} {{-- pagination links --}} # change the amount of posts shown on each side of the current page by putting it through the onEachSide() method
'php artisan vendor:publish --tag=laravel-pagination' # to edit or view the built in pagination method, so if you want to change it, you can
  returns : Copying directory [vendor/laravel/framework/src/Illuminate/Pagination/resources/views] to [resources/views/vendor/pagination] ........ DONE
'resources -> views -> vendor -> pagination' where the files will be, you will see multiple files, after running the above command, you can customize the pagination here
'tailwind.blade.php' is what we are currently using, you can also customize it by giving a new '_.blade.php' file as argument for the 'links('_blade.php')' and using your own
'pagination()' that we currently have is numbered, 'simplePaginate()' will only show prev/next

1:33:19 - Blade Directives ==================================================================================================================================================================
https://laravel.com/docs/12.x/blade
notable directives : @auth     // The user is authenticated... @endauth - @guest     // The user is not authenticated... @endguest
Loops Directives:
@for ($i = 0; $i < 10; $i++)     The current value is {{ $i }}@endfor
 @foreach ($users as $user)    <p>This is user {{ $user->id }}</p>@endforeach
 @forelse ($users as $user)    <li>{{ $user->name }}</li>@empty    <p>No users</p>@endforelse
 @while (true)    <p>I'm looping forever.</p>@endwhile
@if (count($records) === 1)    I have one record!@elseif (count($records) > 1)    I have multiple records!@else    I don't have any records!@endif
Switch statements/cases - theres a tonne, future Sean problems 

1:37:46 - Components =========================================================================================================================================================================
https://laravel.com/docs/12.x/blade#components
Tangent : React Vs Laravel Components, an AI response :
No, Laravel and React components are not the same; they serve completely different purposes and operate on different parts of the application stack.
Laravel Components (server side, static) :
Laravel components are server-side PHP files that are used to create reusable pieces of a view. 
  They are processed and rendered on the server before the final HTML is sent to the user's browser. 
  You use them for things like UI elements (e.g., alerts, buttons) or sections of a page (e.g., a header) that you want to reuse across different Blade templates. 
  They are simple, static building blocks for a server-rendered application.
Example: A Blade component for an alert would be defined in a .blade.php file and used like this: '<x-alert type="error" :message="$message" />'. The final output is static HTML.
React Components (client side, dynamic) :
React components are client-side JavaScript functions or classes that render to the browser. 
  They are the fundamental building blocks of a user interface (UI) in a single-page application (SPA). React components are dynamic and interactive,
  as they can manage their own state and re-render based on user input or data changes without requiring a full page reload from the server. 
  They are designed for creating rich, interactive user experiences.
Example: A React component for a button would be defined in a .js or .jsx file and used like this: '<Button onClick={handleClick} />'. 
  The button's behavior and appearance are managed by JavaScript in the user's browser.
Components are reusable pieces of code, mostly related to UI, DRY = don't repeat yourself, create one component and reuse it in your code
In PHP there are 3 types of components, one is class based(php class associated to a blade file), view only components(only blade file), inline components(only have php class)
'php artisan make:component PostItem' # will create 2 files Component [app/View/Components/PostItem.php] created successfully.  [resources/views/components/post-item.blade.php] 
'PostItem.php' # where the functionality of the component can be created, this is where the 'class' is, how you can interact with the database, etc
'post-item.blade.php' # where the view/visual aspect of the component can be created (both are blank default)
'php artisan make:component PostItem --view' # will create a component, but only the view part [resources/views/components/post-item.blade.php]
'<x-post-item :post="$post" />' # Every component that you use will need to start with 'x' prefix, the ':post="$post"' is how you provide the '$post' variable to the component
  The way you pass variables in Blade components is very similar to how you pass props in React. 
  Both systems are designed to make components reusable by allowing you to inject data from a parent into a child component.
  The ':post' attribute in Blade is the equivalent of the post prop in React. The colon (:) tells Blade to treat the value on the right ("$post") as a PHP variable.
So whenever you see some code in a '_.blade.php' file starting with '<x-...>' you can know it's a component and find it under 'resources -> views -> components -> _.blade.php'
'php artisan make:component CategoryTabs' # Component [app/View/Components/CategoryTabs.php] created successfully. [resources/views/components/category-tabs.blade.php] 
There are 2 ways to pass data from the 'CategoryTabs' class into the blade file, 1) define public properties, 2) variable declaration
Anything you put in between the <x-component>This Text is Slot Text</x-component> tags will be able to be referenced in the class 'component.php' file as {{ $slot }}

1:50:06 - Layouts ============================================================================================================================================================================
Download a new 'logo.svg' for medium.com - To change the logo from laravel go to :
'resources -> views -> layouts -
'app.blade.php' =  serves as the master layout for the application, defining a consistent structure like the header, navigation, and footer for authenticated user pages, actually a component
'guest.blade.php' = provides a specific, minimalist layout for pages accessible to guests, such as the login, registration, and password reset pages.
'navigation.blade.php' = navbar that is then '@include' directive to the 'app.blade.php' as a component
'<html lang="{{ str_replace('_', '-', app()->getLocale()) }}">' # the 'getLocale()' function gets the local(language) from your '.env' file, which defaults to 'en'
'<title>{{ config('app.name', 'Laravel') }}</title>' # this is the title for your website, the default is Laravel, change this in the 'APP_NAME' in the '.env' file
  'APP_NAME="Medium Clone"' #don't forget to add quotes for spaces when changing your title
'@vite(['resources/css/app.css', 'resources/js/app.js'])' # vite directive handles the 'app.css' and the 'app.js', handled by vite server
'public -> build -> assets' # some wierdly named JS and CSS files here (hashed names), every time you change your CSS/JS it will change your hash, vite will handle the name changes auto
'@include('layouts.navigation')' # another directive that includes another blade file found in 'resources -> 'layouts -> navigation.blade.php' which is your navbar
'<div>{{ Auth::user()->name }}</div>' # This code displays the name of the currently authenticated user by accessing the user object through the Auth facade.
'{{ __('Profile') }}' # __('Profile'): This is a Laravel translation helper function. The __() function looks up the string 'Profile' in your application's language files 
  (located in the lang directory). If your app is set to English, it will simply output "Profile". If it's set to another language, like Spanish, it will output "Perfil"
  (if you've provided the translation). In short, this code displays the word "Profile" while making your application easy to translate into multiple languages.
update the routes for the new URL in 'routes -> 'web.php'
'Route::get('/dashboard', [PostController::class, 'index'])->middleware(['auth', 'verified'])->name('dashboard');' # changed to below, so instead of the URL needing '/dashboard' it is now '/'
'Route::get('/', [PostController::class, 'index'])->middleware(['auth', 'verified'])->name('dashboard');'
'app.blade.php' is actually a component, typically components are stored in the 'resources -> views components' folder, this one is stored in 'view -> layouts' 
'<x-app-layout>' which is in the 'app -> View -> Components' folder is how to reference it - that's alot of stuff future Sean won't remember :
  Basically for the app-layout, it's not in it's normal spot where components are normally stored, it's in another place
'app -> View -> Components -> AppLayout.php' actyally renders the file below from 'layouts.app' :
class AppLayout extends Component
{
    /**
     * Get the view / contents that represents the component.
     */
    public function render(): View
    {
        return view('layouts.app');
    }
}

2:08:10 - Create New Post ===================================================================================================================================================================
First, add a button to the navbar in 'navigation.blade.php'
Did a bunch of stuff, forgot to take notes, created 2 new routes in 'web.php' a new 'create.blade.php' and new button, also fixed some tailwind CSS
Route::middleware(['auth', 'verified'])->group(function () {
    Route::get('/', [PostController::class, 'index'])
        ->name('dashboard');
    Route::get('/post/create', [PostController::class, 'create'])
        ->name('post.create');
}); # instead of having 'Route::middleware(['auth', 'verified'])->group(function ()' in each 'Route::get', you can simply wrap the routes in a 'Route::middleware' that will check for auth
# below is from a new component we made 'components -> input-textarea', 
<textarea @disabled($disabled) {{ $attributes->merge(['class' => 'border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-md shadow-sm']) }}>
# the '$attributes' is a special keyword that outputs every attribute that is given to the 'x-input-textarea' from 'create.blade.php' and adds them to the component,  
  so the 'id' 'class' 'type' 'name' ':value' 'required' etc get added to the component, despite the fact the component is used in the create.blade.php
# the 'merge()' method takes all of the '$attributes' given to the component and merges them into the 'class' of the component (from child 'class' to parent 'class' and combines them)
                    <div class="mt-4">
                        <x-input-label for="content" :value="__('Content')" />
                        <x-input-textarea id="content" class="block mt-1 w-full" type="text" name="content"
                            :value="old('content')" required ></x-input-textarea>
                        <x-input-error :messages="$errors->get('content')" class="mt-2" />
                    </div>
# the '@disabled($disabled)' is a directive that if true adds disabled, if false does not, give ':disabled="true' to disable the component (it defaults to false)
https://flowbite.com/docs/forms/file-input/
'@csrf' # will generate an unguessable string/hash/token that you can use to submit forms from an authenticated user, this is a submitted form 'dd' notice the "_token" that is the '@csrf'
array:4 [▼ // app/Http/Controllers/PostController.php:77
  "_token" => "P3N50Xjb8hA91KrijaiDhkJVgKwBo2TRUDiyWxvL"
  "image" => "1754684820741985 (1).jpg"
  "title" => "test"
  "content" => "1"
]
<form action="{{ route('post.store') }}" method="post" enctype="multipart/form-data"> 
  # 'enctype' tells the browser how to format the data for submission, with multipart/form-data being the required value for forms that include file uploads.
#how to validate the form data submitted by user 'PostController.php', add multiple validation rules with the '|' pipe means 'and' or add the rules in an array ['rule1', 'rule2']
public function store(Request $request)
    {
        $request->validate([
            'image' => 'required|image|mimes:jpeg,png,jpg,gif,svg|max:2048', 
            'title' => 'required',
            'content' => 'required',
            'category_id' => ['required', 'exists:categories,id'], # the category is required, and needs to exist in the categories table
        ]);
    }
# how to do a dropdown menu with a '@foreach' directive loop 
<!-- Category -->
                    <div class="mt-4">
                        <x-input-label for="category_id" :value="__('Category')" />
                        <select id="category_id" name="category_id"
                            class="block mt-1 w-full border-gray-300 focus:border-indigo-500 focus:ring-indigo-500 rounded-md shadow-sm">
                            <option value="">Select a category</option>
                            @foreach ($categories as $category)
                                <option value="{{ $category->id }}"
                                    {{ old('category_id') == $category->id ? 'selected' : '' }}>
                                    @selected(old('category_id') == $category->id) #'@selected' directive will save your selection and persist through a form submission failure
                                    {{ $category->name }}</option>
                            @endforeach
                        </select>
                        <x-input-error :messages="$errors->get('category_id')" class="mt-2" />
                    </div>
# to protect our database, the 'Models -> post.php' needs to match our migration 
class Post extends Model
{
    use HasFactory;

    protected $fillable = [
        'image',
        'title',
        'slug',
        'content',
        'category_id',
        'user_id',
        'published_at',
    ];
}
# 'migrations -> create_posts_table' this will match our 'protected $fillable' from 'post.php' to validate the form submission to the database
return new class extends Migration
{
    public function up(): void
    {
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->string('image')->nullable();
            $table->string('title');
            $table->string('slug')->unique();
            $table->longText('content');
            $table->foreignId('category_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->timestamp('published_at')->nullable();
            $table->timestamps();
        });
    }
'php artisan storage:link' # The [public/storage] link has been connected to [storage/app/public]. - Creates a symbolic link inside 'public' folder from 'storage/app/public' 
  'storage/app/public' is where the file is uploaded, but is not accesible by the web, so you need to create a link
'php artisan tinker ->  $p = \App\Models\Post::latest()->first();' # assigns to '$p' the latest post you uploaded to database, now all you need to type to get newest post is '$p'
We hardcoded the images because the 'image()' function was broken, so 'post-item.blade.php' now uses dynamic image from the database, 
<img class="rounded-r-lg w-48 h-full max-h-64 object-cover" src="{{ Storage::url($post->image) }}" alt="" /> # 'src="{{ Storage::url($post->image) }}"' Will get the image from the DB
# in order to fix the images, he attempted to put the hardcoded URL in the database, but it prefixed it with the '/storage/' because of the link, doesn't matter, we are creating our own
'php artisan tinker -> \App\Models\Post::where('id', '<101'->update(['image' => 'https://flowbite.com/docs/images/blog/image-1.jpg'])'
'php artisan migrate:fresh' # start with a new migration now that we got posts to work

2:54:36 - Profile Update Page ===============================================================================================================================================================
'/profile' Add an 'Avatar', 'Username', 'Bio'
Update an old Migration file or Use a new migration : if you are working locally and not pushing changes, updating an old migration is fine, if you are working in a team, new migration
  You don't want to use an old updated migration, because if you do, you will have to drop ALL your old data in your database (not a good idea) - instead use a new migration
  If you already have a production database : USE A NEW MIGRATION
'php artisan make:migration add_columns_to_users_table' # create a new migration to add new columns to our 'users' table
// The `up()` method is the main method of a migration. It defines the changes that will be applied to the database.
// When you run the `php artisan migrate` command, Laravel executes this method to update the schema.
public function up(): void
{
    // `Schema::table()`: This is a static call to the `Schema` facade.
    // The `table()` method is used to modify an existing table in the database.
    // - The first argument, 'users', is the name of the table we want to modify.
    // - The second argument is a closure (an anonymous function) that receives a `Blueprint` object.
    Schema::table('users', function (Blueprint $table) {
        
        // `->string('username')`: This method adds a new column named `username` with a `string` data type (which maps to VARCHAR in most databases).
        // `->unique()`: This chained method adds a unique index to the `username` column, ensuring that no two users can have the same username.
        // `->after('id')`: This chained method specifies that the new `username` column should be placed immediately after the `id` column in the table.
        $table->string('username')->unique()->after('id');
        
        // `->string('image')`: Adds a new `string` column named `image`.
        // `->nullable()`: This chained method allows the `image` column to store `NULL` values. This is useful because not every user might have a profile image.
        // `->after('email_verified_at')`: Specifies that the `image` column should be placed after the `email_verified_at` column.
        $table->string('image')->nullable()->after('email_verified_at');
        
        // `->text('bio')`: Adds a new `text` column named `bio`. The `text` type is suitable for longer strings like a user's biography.
        // `->nullable()`: Allows the `bio` column to be `NULL`.
        // `->after('image')`: Specifies that the `bio` column should be placed after the `image` column.
        $table->text('bio')->nullable()->after('image');
    });
}
'php artisan migrate:fresh --seed' # since we changed DB, new migration
Everytime you add new columns, you need to update your Factory/Seeder, just spent half an hour trying to fix bugs.
'resources -> views -> profile -> edit.blade.php' # where the edit profile that was created is stored, it also imports components from the 'partials' folder in this directory
'@include('profile.partials.update-profile-information-form')' # component for editing profile found in 'resources -> views -> profile -> partials ->update-profile-information-form.blade.php
'@method('patch)' # 'method spoofing' in a html typical form element can not be 'patch' it can only 'method="get" or "post" - "patch" updates the profile
'php artisan make:request PostCreateRequest' # instead of doing the data validation in the controller or as a '(Request $request)' we can make our own 'ProfileCreateRequest' for validation
  #  INFO  Request [app/Http/Requests/PostCreateRequest.php] created successfully. Inside 'public function authorize(): bool {return false;}' false by default
So we moved the validation information from the controller into a request class
':value="old('username', $user->username)")' # the old function takes the data that was previously submitted and saves it so it persists between submits (IE form wasn't validated correctly)
  # the second value '$user->username' is the default value that is given, so in order to save the data, you need to provide it in the dynamic option like below
':value="old('bio')"' and '{{ old('bio', $user->bio) }}' # you have to request the bio from '$user' to save it so it persists (this is the slot)

3:21:41 - Post Details Page ===================================================================================================================================================================
On the actual medium post page it contains title, read time, avatar, follow, date posted, likes, comments, we will need to implement all these features














