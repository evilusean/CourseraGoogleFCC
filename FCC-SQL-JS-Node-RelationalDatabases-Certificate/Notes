Start : 12March2025

Each project is it's own DB to work with, going to seperate the notes into each one - then centralize here

12March2025 - Learn Bash by Building a Boilerplate ===========================================================================================================================================
The terminal allows you to send text commands to your computer that can manipulate the file system, run programs, automate tasks, and much more.
In this 170-lesson course, you will learn terminal commands by creating a website boilerplate using only the command line.
https://gitpod.io/workspaces # log in with github account
https://freecodecam-learnbashby-hx2fxtvj2i1.ws-us118.gitpod.io/
# after installing a few extensions in VS code, you can now run the gitpod project in VSCode on linux via SSH shell, 
had a bunch of files to start tutorial with in source control, commited them(super slow), still commiting, added 'TUTORIAL.md' since that seems to be the main file
It's telling me to find a 'package.json' and a 'node_modules' file that doesn't exist, also still commiting.. seems broke, but idk, new tool
-Clicking the "hamburger" menu near the top left of the VSCode window,
-Going to the "View" menu,
-Clicking on the "Command Palette" option,
-and running the "CodeRoad: Start" command
#figured it out, needed to run 'CodeRoad: Start' at the top, not commit, the commmit was broken because it was waiting for a message - that took an embarassing long time to figure out
`pwd` stands for "print working directory".
`ls` stands for "list"
  'ls -l' #you can add the '-l' long flag to show more details, like time created, and privileges
  'ls -a' # 'ls --all' shows all files, including hidden ones
`cd` stands for "change directory" 
'more <filename>' = You can see what's in a file with more <filename>. Use it to view what's in the package.json
'clear' = clear terminal
'cd ../..' = You can go back two folders with cd ../.. Each set of dots represents another folder level. 
'mkdir' = make directory
'touch <filename>' = create a new file
'cp <file> <destination>' = copies a (or multiple) files to <destination>
  'cp -r <file> <destination>' = will copy recursively, so you can copy folders instead of just files
'rm <filename>' = removes file
  'rm -r' = 'r' is recursive flag, be careful you can destroy your OS doing this
'mv <filename> <new_filename>' = mv stands for "move", it can rename or move something.
'find' = to find things or view a file tree. Enter find to view the file tree of the website folder to see all the files and folders within it.
'find <folder_name>' = to display the tree of a different folder.
'find -name <filename>' = search for a filename
'rmdir' = remove directory
'echo <text> >> <filename>' You can print to a file instead of the terminal with '>>'

14March2025 - Learn Relational Databases by Building a Mario Database ========================================================================================================================
https://www.freecodecamp.org/learn/relational-database/learn-relational-databases-by-building-a-mario-database/build-a-mario-database
View -> Command Pallet -> Start with 'CoadRoad : Start' 
'psql --username=freecodecamp --dbname=postgres' #login credentials for tutorial, after signing in, gives you a new prompt 'postgres=>' 
\l # list, while signed into the new postgreSQL db, by using the credentials above, will show a list of all databases
CREATE DATABASE database_name; #a way to create a new database - The capitalized words are keywords telling PostgreSQL what to do. The name of the database is the lowercase word. 
  Note that all commands need a semi-colon at the end. - the keywords are also CAP SENSITIVE, need to be capitalized 
  If you don't get a message after entering a command, it means it's incomplete and you likely forgot the semi-colon.
\c database_name #You can connect to a database by entering \c database_name. You need to connect to add information. , the prompt will change to 'database_name'
\d #display the tables of the currently connected to DB
  \d table_name #You can view more details about a table by adding the table name after the display command like this: \d table_name
CREATE TABLE table_name(); #similar to creating a database, Note that the parenthesis are needed for this one. It will create the table in the database you are connected to
ALTER TABLE table_name ADD COLUMN column_name DATATYPE; #Tables need columns to describe the data in them, yours doesn't have any yet. Here's an example of how to add one
ALTER TABLE table_name DROP COLUMN column_name; #will drop a column (delete it)
VARCHAR = A common data type is VARCHAR. It's a short string of characters. You need to give it a maximum length when using it like this: VARCHAR(30).
ALTER TABLE table_name RENAME COLUMN column_name TO new_name; # Here's how you can rename a column
INSERT INTO table_name(column_1, column_2) VALUES(value1, value2); # Rows are the actual data in the table. You can add one like this, strings must be in ' single quotes
SELECT columns FROM table_name;  #You can view the data in a table by querying it with the SELECT statement
SELECT * from table_name; #view all data from table_name, '*' = all
DELETE FROM table_name WHERE condition; #Here's an example of how to delete a row
DELETE FROM second_table WHERE username='Luigi'; #deletes from the 'second_table' the row where username='Luigi', all data on the row where username='Luigi' will be deleted, not just username
DROP TABLE table_name; #will drop(delete) a table from your database
ALTER DATABASE database_name RENAME TO new_database_name; #You can rename a database like this:
ALTER TABLE characters ADD COLUMN character_id SERIAL; #The SERIAL type will make your column an INT with a NOT NULL constraint, and automatically increment the integer when a new row is added.
ALTER TABLE characters ADD COLUMN name VARCHAR(30)NOT NULL; 
  #Add a column to characters called name. Give it a data type of VARCHAR(30), and a constraint of NOT NULL. Add a constraint by putting it right after the data type.
Adding rows one at a time is quite tedious. Here's an example of how you could have added the previous three rows at once:
  INSERT INTO characters(name, homeland, favorite_color)
  VALUES('Mario', 'Mushroom Kingdom', 'Red'),
  ('Luigi', 'Mushroom Kingdom', 'Green'),
  ('Peach', 'Mushroom Kingdom', 'Pink');
UPDATE table_name SET column_name=new_value WHERE condition; # You can change a value like this
SELECT columns FROM table_name ORDER BY column_name; #order columns by 
SELECT * FROM characters ORDER BY character_id; #will order all colums from characters by ascending character_id
ALTER TABLE table_name ADD PRIMARY KEY(column_name); #  add a primary key. It's a column that uniquely identifies each row in the table. Here's an example of how to set a PRIMARY KEY
  You should set a primary key on every table and there can only be one per table.
ALTER TABLE table_name DROP CONSTRAINT constraint_name; # It would have been better to use character_id for the primary key. Here's an example of how to drop a constraint:
ALTER TABLE more_info ADD COLUMN weight NUMERIC(4,1); # 
  Add a weight column. Give it a type of NUMERIC(4, 1). That data type is for decimals. NUMERIC(4, 1) has up to four digits and one of them has to be to the right of the decimal.
ALTER TABLE table_name ADD COLUMN column_name DATATYPE REFERENCES referenced_table_name(referenced_column_name); #
  To know what row is for a character, you need to set a foreign key so you can relate rows from this table to rows from your characters table. 
  Here's an example that creates a column as a foreign key:
ALTER TABLE more_info ADD COLUMN character_id INT REFERENCES characters(character_id); 
  #creates a new column named 'character_id' that references our unique identifier PRIMARY KEY on the 'characters' table from the column 'character_id' as a FOREIGN KEY on 'more_info' table
ALTER TABLE table_name ADD UNIQUE(column_name); #There's your foreign key at the bottom. These tables have a "one-to-one" relationship. 
  One row in the characters table will be related to exactly one row in more_info and vice versa. Enforce that by adding the UNIQUE constraint to your foreign key. Here's an example
ALTER TABLE table_name ALTER COLUMN column_name SET NOT NULL; #The column should also be NOT NULL since you don't want to have a row that is for nobody.
ALTER TABLE more_info ALTER COLUMN character_id SET NOT NULL; 
ALTER TABLE sounds ADD COLUMN filename VARCHAR(40) NOT NULL UNIQUE; #adding 2 constraints, 'not null' and 'unique'
ALTER TABLE table_name ADD COLUMN column_name DATATYPE CONSTRAINT REFERENCES referenced_table_name(referenced_column_name);
ALTER TABLE sounds ADD COLUMN character_id INT NOT NULL REFERENCES characters(character_id);
  # You want to use character_id as a foreign key again. 
  This will be a "one-to-many" relationship because one character will have many sounds, but no sound will have more than one character. Here's the example again:
INSERT INTO sounds(filename, character_id) VALUES('yay.wav', 3), ('woo-hoo.wav', 3); #inputting multiple audios at once
"Many-to-many" relationships usually use a junction table to link two tables together, forming two "one-to-many" relationships.
  Your characters and actions table will be linked using a junction table. Create a new table called character_actions. It will describe what actions each character can perform.
ALTER TABLE table_name ADD FOREIGN KEY(column_name) REFERENCES referenced_table(referenced_column);
ALTER TABLE character_actions ADD FOREIGN KEY(character_id) REFERENCES characters(character_id);
  #The foreign keys you set before were added when you created the column. You can set an existing column as a foreign key like this:
ALTER TABLE table_name ADD PRIMARY KEY(column1, column2);  #Every table should have a primary key. 
  #Your previous tables had a single column as a primary key. This one will be different. You can create a primary key from two columns, known as a composite primary key.
ALTER TABLE character_actions ADD PRIMARY KEY(character_id, action_id);
SELECT columns FROM table_1 FULL JOIN table_2 ON table_1.primary_key_column = table_2.foreign_key_column;
  You can see the character_id there so you just need to find the matching id in the characters table to find out who it's for. Enter a join command to see all the info from both tables
  Or... You added that as a foreign key, that means you can get all the data from both tables with a JOIN command: 
SELECT * FROM characters FULL JOIN more_info ON characters.character_id = more_info.character_id;
SELECT * FROM character_actions FULL JOIN characters ON character_actions.character_id = characters.character_id FULL JOIN actions ON character_actions.action_id = actions.action_id;
  SELECT columns FROM junction_table
  FULL JOIN table_1 ON junction_table.foreign_key_column = table_1.primary_key_column
  FULL JOIN table_2 ON junction_table.foreign_key_column = table_2.primary_key_column;
    #This shows the "one-to-many" relationship. You can see that some of the characters have more than one row because they have many sounds.
    How can you see all the info from the characters, actions, and character_actions tables? Here's an example that joins three tables:

 : 17March2025 - Building A Celestial Bodies PostgreSQL Database ========================================================================================================================
https://www.freecodecamp.org/learn/relational-database/build-a-celestial-bodies-database-project/build-a-celestial-bodies-database
Step 1: Complete the project
The project runs in a virtual machine, complete the user stories described in there and get all the tests to pass to finish step 1.
Important: After you pass all the project tests, save a dump of your database into a universe.sql file so you can complete step 
2. There will be instructions how to do that within the virtual machine.
Login to Gitpod with your GitHub account if you aren't already
Once the virtual Linux machine is finished loading, start the CodeRoad extension by:
Clicking the "hamburger" menu near the top left of the VSCode window,
Going to the "View" menu,
Clicking on the "Command Palette" option,
and running the "CodeRoad: Start" command
Follow the instructions in CodeRoad to complete the course
psql --username=freecodecamp --dbname=postgres #login 
pg_dump -cC --inserts -U freecodecamp universe > universe.sql #instead of finishing it in one multi hour session, how to 'dump eet' and save
InstructSeans :
Instructions
For this project, you need to log in to PostgreSQL with psql to create your database. Do that by entering psql --username=freecodecamp --dbname=postgres in the terminal. 
  Make all the tests below pass to complete the project. Be sure to get creative, and have fun!
Don't forget to connect to your database after you create it 😄
Here's some ideas for other column and table names: description, has_life, is_spherical, age_in_millions_of_years, planet_types, galaxy_types, distance_from_earth.
Notes:
If you leave your virtual machine, your database may not be saved. You can make a dump of it by entering pg_dump -cC --inserts -U freecodecamp universe > universe.sql in a bash terminal 
  (not the psql one). It will save the commands to rebuild your database in universe.sql. The file will be located where the command was entered. 
  If it's anything inside the project folder, the file will be saved in the VM. You can rebuild the database by entering psql -U postgres < universe.sql in a terminal where the .sql file is.
If you are saving your progress on freeCodeCamp.org, after getting all the tests to pass, follow the instructions above to save a dump of your database. 
  Save the universe.sql file in a public repository and submit the URL to it on freeCodeCamp.org.
Complete the tasks below : 
You should create a database named universe
  CREATE DATABASE universe;
Be sure to connect to your database with \c universe. Then, you should add tables named galaxy, star, planet, and moon
  \c universe
Each table should have a primary key
Each primary key should automatically increment
Each table should have a name column
You should use the INT data type for at least two columns that are not a primary or foreign key
You should use the NUMERIC data type at least once
You should use the TEXT data type at least once
You should use the BOOLEAN data type on at least two columns
  CREATE TABLE galaxy (
      galaxy_id SERIAL PRIMARY KEY,
      name VARCHAR(50) UNIQUE NOT NULL,
      age_in_billions_of_years NUMERIC(5,1),
      diameter_in_light_years INT NOT NULL,
      number_of_stars INT,
      is_spiral BOOLEAN NOT NULL,
      has_black_hole BOOLEAN
  );
Each "star" should have a foreign key that references one of the rows in galaxy
  CREATE TABLE star (
      star_id SERIAL PRIMARY KEY,
      name VARCHAR(50) UNIQUE NOT NULL,
      galaxy_id INT REFERENCES galaxy(galaxy_id) NOT NULL,
      temperature_in_kelvin INT,
      mass_solar_units NUMERIC(8,2) NOT NULL,
      is_binary BOOLEAN,
      has_planets BOOLEAN NOT NULL,
      spectral_type TEXT
  );
Each "planet" should have a foreign key that references one of the rows in star
  CREATE TABLE planet (
      planet_id SERIAL PRIMARY KEY,
      name VARCHAR(50) UNIQUE NOT NULL,
      star_id INT REFERENCES star(star_id) NOT NULL,
      orbital_period_in_days INT,
      diameter_in_km INT NOT NULL,
      has_atmosphere BOOLEAN,
      is_habitable BOOLEAN NOT NULL,
      description TEXT,
      distance_from_star_in_au NUMERIC(10,2)
  );
Each "moon" should have a foreign key that references one of the rows in planet
  CREATE TABLE moon (
      moon_id SERIAL PRIMARY KEY,
      name VARCHAR(50) UNIQUE NOT NULL,
      planet_id INT REFERENCES planet(planet_id) NOT NULL,
      diameter_in_km INT,
      distance_from_planet_in_km INT NOT NULL,
      is_spherical BOOLEAN,
      has_water BOOLEAN NOT NULL,
      surface_description TEXT
  );
Your database should have at least five tables
  CREATE TABLE asteroid (
      asteroid_id SERIAL PRIMARY KEY,
      name VARCHAR(50) UNIQUE NOT NULL,
      diameter_in_km INT NOT NULL,
      is_potentially_hazardous BOOLEAN,
      orbit_crosses_earth BOOLEAN NOT NULL,
      composition TEXT,
      discovery_year INT
  );
Each table should have at least three rows
  INSERT INTO galaxy (name, age_in_billions_of_years, diameter_in_light_years, number_of_stars, is_spiral, has_black_hole)
  VALUES 
      ('Milky Way', 13.6, 100000, 4000, TRUE, TRUE),
      ('Andromeda', 10.1, 220000, 1000, TRUE, TRUE),
      ('Triangulum', 10.0, 60000, 4000, TRUE, FALSE),
      ('Centaurus A', 13.3, 60000, 1000, FALSE, TRUE),
      ('Whirlpool', 0.4, 60000, 1000, TRUE, FALSE),
      ('Sombrero', 13.25, 50000, 1000, FALSE, TRUE);
The galaxy and star tables should each have at least six rows
  INSERT INTO galaxy (name, age_in_billions_of_years, diameter_in_light_years, number_of_stars, is_spiral, has_black_hole)
  VALUES 
      ('Milky Way 2', 13.6, 100000, 4000, TRUE, TRUE),
      ('Andromeda Galaxy', 10.1, 220000, 1000, TRUE, TRUE),
      ('Triangulum Galaxy', 10.0, 60000, 400, TRUE, FALSE),
      ('Centaurus A Galaxy', 13.3, 60000, 100, FALSE, TRUE),
      ('Whirlpool Galaxy', 0.4, 60000, 1000, TRUE, FALSE),
      ('Sombrero Galaxy', 13.25, 50000, 100, FALSE, TRUE);
  INSERT INTO star (name, galaxy_id, temperature_in_kelvin, mass_solar_units, is_binary, has_planets, spectral_type)
  VALUES 
      ('Sun', 1, 5778, 1.00, FALSE, TRUE, 'G2V'),
      ('Proxima Centauri', 1, 3042, 0.12, TRUE, TRUE, 'M5.5Ve'),
      ('Betelgeuse', 1, 3500, 11.60, FALSE, FALSE, 'M1-2Ia-Iab'),
      ('Sirius', 1, 9940, 2.02, TRUE, FALSE, 'A0mA1Va'),
      ('Alpha Centauri A', 1, 5790, 1.10, TRUE, TRUE, 'G2V'),
      ('Vega', 1, 9602, 2.10, FALSE, TRUE, 'A0Va');
The planet table should have at least 12 rows
  INSERT INTO planet (name, star_id, orbital_period_in_days, diameter_in_km, has_atmosphere, is_habitable, description, distance_from_star_in_au)
  VALUES 
      ('Earth', 1, 365, 12742, TRUE, TRUE, 'Blue planet with diverse ecosystems', 1.00),
      ('Mars', 1, 687, 6779, TRUE, FALSE, 'Red planet with thin atmosphere', 1.52),
      ('Venus', 1, 225, 12104, TRUE, FALSE, 'Hot planet with thick atmosphere', 0.72),
      ('Mercury', 1, 88, 4879, FALSE, FALSE, 'Small rocky planet closest to the Sun', 0.39),
      ('Jupiter', 1, 4333, 139820, TRUE, FALSE, 'Largest gas giant in our solar system', 5.20),
      ('Saturn', 1, 10759, 116460, TRUE, FALSE, 'Gas giant with prominent ring system', 9.58),
      ('Uranus', 1, 30687, 50724, TRUE, FALSE, 'Ice giant with tilted axis', 19.22),
      ('Neptune', 1, 60190, 49244, TRUE, FALSE, 'Blue ice giant with strong winds', 30.05),
      ('Proxima b', 2, 11, 12000, TRUE, TRUE, 'Potentially habitable exoplanet', 0.05),
      ('Kepler-186f', 6, 130, 11000, TRUE, TRUE, 'Earth-sized exoplanet in habitable zone', 0.40),
      ('HD 209458 b', 6, 3.5, 94000, TRUE, FALSE, 'Hot Jupiter exoplanet', 0.05),
      ('TRAPPIST-1e', 5, 6, 9200, TRUE, TRUE, 'Rocky exoplanet in habitable zone', 0.03);
The moon table should have at least 20 rows
  INSERT INTO moon (name, planet_id, diameter_in_km, distance_from_planet_in_km, is_spherical, has_water, surface_description)
  VALUES 
      ('Luna', 1, 3474, 384400, TRUE, TRUE, 'Cratered surface with maria'),
      ('Phobos', 2, 22, 9376, FALSE, FALSE, 'Irregular potato-shaped moon'),
      ('Deimos', 2, 12, 23463, FALSE, FALSE, 'Small irregular moon'),
      ('Io', 5, 3643, 421700, TRUE, FALSE, 'Volcanic active surface'),
      ('Europa', 5, 3122, 671034, TRUE, TRUE, 'Icy surface with subsurface ocean'),
      ('Ganymede', 5, 5268, 1070412, TRUE, TRUE, 'Largest moon in solar system'),
      ('Callisto', 5, 4821, 1882709, TRUE, TRUE, 'Heavily cratered surface'),
      ('Titan', 6, 5150, 1221870, TRUE, TRUE, 'Thick atmosphere and liquid methane'),
      ('Enceladus', 6, 504, 238020, TRUE, TRUE, 'Icy moon with water geysers'),
      ('Mimas', 6, 396, 185539, TRUE, FALSE, 'Death Star-like crater'),
      ('Tethys', 6, 1062, 294619, TRUE, TRUE, 'Large impact crater'),
      ('Dione', 6, 1123, 377396, TRUE, TRUE, 'Bright icy moon'),
      ('Rhea', 6, 1527, 527108, TRUE, TRUE, 'Second largest moon of Saturn'),
      ('Iapetus', 6, 1469, 3560820, TRUE, FALSE, 'Two-toned coloration'),
      ('Miranda', 7, 472, 129390, TRUE, FALSE, 'Varied and extreme surface features'),
      ('Ariel', 7, 1158, 190900, TRUE, TRUE, 'Bright surface with few craters'),
      ('Umbriel', 7, 1169, 266000, TRUE, FALSE, 'Dark surface with many craters'),
      ('Titania', 7, 1578, 436300, TRUE, TRUE, 'Largest moon of Uranus'),
      ('Oberon', 7, 1523, 583500, TRUE, TRUE, 'Heavily cratered surface'),
      ('Triton', 8, 2707, 354759, TRUE, TRUE, 'Retrograde orbit with nitrogen geysers');
Each table should have at least three columns
  INSERT INTO asteroid (name, diameter_in_km, is_potentially_hazardous, orbit_crosses_earth, composition, discovery_year)
  VALUES 
      ('Ceres', 939, FALSE, FALSE, 'Rocky with water ice', 1801),
      ('Vesta', 525, FALSE, FALSE, 'Basaltic surface', 1807),
      ('Apophis', 370, TRUE, TRUE, 'Silicate rock', 2004);
The galaxy, star, planet, and moon tables should each have at least five columns
At least two columns per table should not accept NULL values
At least one column from each table should be required to be UNIQUE
All columns named name should be of type VARCHAR
Each primary key column should follow the naming convention table_name_id. For example, the moon table should have a primary key column named moon_id
Each foreign key column should have the same name as the column it is referencing
'\q' to quit PostgreSQL terminal then type 'pg_dump -cC --inserts -U freecodecamp universe > universe.sql' to save the commands for tutorial

19March2025 - Learn Bash Scripting by Building Five Programs =============================================================================================================================
https://www.freecodecamp.org/learn/relational-database/learn-bash-scripting-by-building-five-programs/build-five-programs
'sh questionnaire.sh' # you need a prefix with 'sh' similar to './' to run a shell script 'sh' stands for shell
'bash questionnaire.sh' # to run it in 'bash' born again shell
'which bash' # '/usr/bin/bash' where bash lives, 'which' shows where a program is 
'#!<path_to_interpreter>' # shebang shebang oh baby she move she move I go crazy, she rook like a butterfly but sting like a bee -
'#!/bin/bash' #tell the computer to run from this path -  tell your computer which interpreter to use - add it to the top of your script
'./questionnaire.sh' #this is what I've been using for years to run my shell scripts
'ls -l <file name>' #will list all privileges for the file 
-rw-r--r--. All but the first character (-) describe permissions different users have with the file. r means read, w means write, x means execute
'chmod +x questionnaire.sh' # in the terminal to give everyone executable permissions.
'VARIABLE_NAME=VALUE' #Bash has variables, functions, and other things you might be familiar with. You can create a variable with VARIABLE_NAME=VALUE. 
  There cannot be any spaces around the equal (=) sign. If a variable has any spaces in it, place double quotes around it. 
'$VARIABLE_NAME' #To use a variable, place '$' in front of it like this: 
'read VARIABLE_NAME' #you want to be able to accept input from a user. You can do that with 'read' like this: 
'echo Hello $NAME.' #to print the name, notice how theres no quote marks or escape characters, I guess you can do it raw in bash
'man echo' #use 'manual' pages to get info about the command 'echo' since 'echo --help' doesn't work
'echo -e "\n~~ Questionnaire ~~\n"' # '-e' flag enables escape characters like '\n' escape character for new line
'touch countdown.sh' #create a new file with touch
'echo $*' #will print whatever the arguments are when running the script for example './countdown.sh arg1 arg2 arg3' will print 'arg1 arg2 arg3'
'echo $1' #will print out the first argument given(there is no variable named '1')
'help' #type JUST 'help' in the bash shell and it will show you ALL available commands
'if' statements syntax (notice the fi at the end? fwhy?) :
  if [[ CONDITION ]]
  then
    STATEMENTS
  else
    STATEMENTS
  fi
Your program is expecting an integer to count down from as its argument. You can compare integers inside the brackets ([[ ... ]]) of your if with 
  -eq (equal), -ne (not equal), -lt (less than), -le (less than or equal), -gt (greater than), -ge (greater than or equal).
  !, &&, and || to compare multiple expressions. There's also == and != operators for an individual expression.
Change your if condition to check if your first argument is less than 5.
  if [[ $1 -lt 5 ]]
  then
    echo true
  else
    echo false
  fi
'echo $?'  #Nothing happened? Each command has an exit status that can be accessed with '$?'. View the exit status of the last command with 'echo $?' exit status '0' = 'true'
';' #you can string statements together into oneliners using ';' '[[ 4 -ge 5 ]]; echo $?' will run '4 > 5' and return the exit code with '$?'
exit code: 127 #command not found, with an exit status of 127. Anything but 0 means there was an error with the command.
exit code: 2 #invalid option/flag
exit code: 1 #command failed
[[ -x countdown.sh ]]; echo $? #check if you have execute permissions for countdown.sh, returns exit code '0' for yes
if statement with 'then' keyword for a countdown 'gt' = greater than '$1' = first argument :
  if [[ $1 -gt 0 ]]
  then
    for (( i = $1; i > 0; i-- ))
    do
      echo $i
    done
  else
    echo Include a positive integer as the first argument.
  fi
'/bin' is binaries folder, and contains commands you can run
'sleep 3' causes the shell/script to stop for 3 seconds before running again
: ' this is a multiline comment in bash ' 
While loop syntax :
  I=$1
  while [[ $I -ge 0 ]]
  do
    echo $I
    (( I-- ))
    sleep 1
  done
'printenv' #print environment
'echo $LANG' #prints environment language variable
'echo $RANDOM' #prints a random number - The RANDOM variable will generate a random number between 0 and 32767 - 
  You can use the modulus operator to make it in the range you want. In your script, change the NUMBER variable to '$RANDOM%75'
echo $(( J * 5 + 25 )) #how to run a mathematical equation on the variable J, and print out the answer
'declare' #new keyword to declare a variable 'declare -p J' will declare the variable J
'echo $(( RANDOM % 75 + 1 ))' #will run random command and give a result from 1-75
Else If Statements Syntax :
  if (( CONDITION ))
  then
    STATEMENTS
  elif [[ CONDITION ]]
  then
    STATEMENTS
  fi
ARR=("a" "b" "c") #syntax for creating an array
echo ${ARR[1]} #how to access that array and print value [1], index is 0 based, so that would be "b", notice it's '{' curly braces not '(' parenthesis
echo ${ARR[*]} #to print every item in the array, 'echo ${ARR[@]}' also works
Function Syntax : 
  FUNCTION_NAME() {
    STATEMENTS
  }
Until Loop Syntax (until loop is very similar to the while loop you used. It will execute the loop until a condition is met.) :
  until [[ CONDITION ]]
  do
    STATEMENTS
  done
'[[ hello =~ el ]]; echo $?' # '=~' equals tilda returns true if there is a partial match, allows pattern matching - this will return '0' for 'true' 
'[[ "hello world" =~ ^h ]]; echo $?' #regex, check if "hello world" starts with h

Start : 21March2025 - Learn SQL by Building a Student Database: Part 1 ========================================================================================================================
Once the virtual Linux machine is finished loading, start the CodeRoad extension by:
Clicking the "hamburger" menu near the top left of the VSCode window,
Going to the "View" menu,
Clicking on the "Command Palette" option,
and running the "CodeRoad: Start" command
'psql --username=freecodecamp --dbname=postgres' #login info
CREATE TABLE <table_name>(); #don't forget the ';' or '()' for the create table statement
ALTER TABLE <table_name> ADD COLUMN <column_name> <TYPE> <CONSTRAINTS>; #to add a column to a table, I just did this 2 days ago and already forgot
ALTER TABLE <table_name> ADD FOREIGN KEY(<column_name>) REFERENCES <referenced_table_name>(<referenced_column_name>); #set a foreign key
ALTER TABLE students ADD FOREIGN KEY(major_id) REFERENCES majors(major_id); # will set the foreign key in the 'students' table that will reference the 'majors' table with column 'majors_id'
ALTER TABLE majors_courses ADD FOREIGN KEY(course_id) REFERENCES courses(course_id); #will use the conjunction table add the foreign key from 'courses' table primary key 'course_id'
  before adding a foreign key to another table, it MUST exist as a primary or unique key in another table - you can combine 2 foreign keys to create a unique key -
  There's one thing missing. This table doesn't have a primary key. The data from courses.csv will go in this table. A single major will be in it multiple times, and same with a course. 
  So neither of them can be a primary key. But there will never be a row with the same two values as another row. So the two columns together, are unique. 
  You can create a composite primary key that uses more than one column as a unique pair like this: ALTER TABLE <table_name> ADD PRIMARY KEY(<column_name>, <column_name>); 
  Add a composite primary key to the table using the two columns.
ALTER TABLE majors_courses ADD PRIMARY KEY(major_id, course_id); #will create a unique key by combing 2 foreign keys in a conjunction table
INSERT INTO majors(major) VALUES('Database Administration'); #how to insert into a created table 'majors' in the column 'major' add the VALUES, this was just one column
INSERT INTO students(first_name, last_name, major_id, gpa) VALUES('Rhea', 'Kellems', 1, 2.5); #how to insert multiple columns at a time 
'insert_data.sh' #creating a script to insert data instead of typing it out like above for each student
'cat courses.csv >> insert_data.sh' #will take all the data from 'courses.csv' and add it to 'insert_data.sh'
#Instead of printing the content, you can pipe that output into a while loop so you can go through the rows one at a time. It looks like this:
  cat courses.csv | while read MAJOR COURSE
  do
    <STATEMENTS>
  done
'declare -p IFS' #the MAJOR variable is only being set to the first word. There's a default IFS variable in bash. IFS stands for "Internal Field Separator".
  #This variable is used to determine word boundaries. It defaults to spaces, tabs, and new lines. This is why the MAJOR variable was set to only the first word on each line from the data. 
'IFS=","' #Between the while and read commands, set the IFS to a comma like this:  Now, it should use the comma in the data to separate words instead of spaces. 
cat courses.csv | while IFS="," read MAJOR COURSE
do
  echo $MAJOR $COURSE
done
#also added courses to the same line 
It helps to plan out what you want to happen. For each loop, you will want to add the major to the database if it isn't in there yet. 
  Same for the course. Then add a row to the majors_courses table. Add these single line comments in your loop in this order: 
  get major_id, if not found, insert major, get new major_id, get course_id, if not found, insert course, get new course_id, insert into majors_courses.
You used the psql command to log in and interact with the database. You can use it to just run a single command and exit. Above your loop, add a PSQL variable that looks like this: 
'PSQL="psql -X --username=freecodecamp --dbname=students --no-align --tuples-only -c"' #This will allow you to query your database from your script. 
  The important parts are the username, dbname, and the -c flag that is for running a single command and exiting. The rest of the flags are for formatting.
'MAJOR_ID=$($PSQL "SELECT major_id FROM majors WHERE major='$MAJOR'")' #read below
  Now, you can query your database using the PSQL variable like this: $($PSQL "<query_here>"). The code in the parenthesis will run in a subshell, which is a separate bash process.
  Below the get major_id comment in your loop, create a MAJOR_ID variable. Set it equal to the result of a query that gets the major_id of the current MAJOR in the loop.
  Make sure to put your MAJOR variable in single quotes.
Below will run if there is major found, and will insert it '-z' flag checks if the string is empty, if it is, it creates a new value in the 'majors' table :
  if [[ -z $MAJOR_ID ]]
  then
    # insert major
    INSERT_MAJOR_RESULT=$($PSQL "INSERT INTO majors(major) VALUES('$MAJOR')")
  fi
'TRUNCATE majors;' #You can use TRUNCATE to delete all data from a table. In the psql prompt, delete all the data in the majors table - in the rare chance you make a mistake
  It says you "cannot truncate a table referenced in a foreign key constraint." The students and majors_courses tables use the major_id from majors as a foreign key. 
  So if you want to delete the data from majors, you need to delete the data from those two tables at the same time. Use TRUNCATE to delete the data from those three tables. 
'TRUNCATE majors, students, majors_courses;' #if you want to DELETE data in one table and it is used as a foreign key in another, you have to delete ALL at ONCE
'if [[ $MAJOR != major ]]' #added to the bash shell script to avoid the initial column, this seems pretty tedious to simply avoid the title rows, but it is bash
'MAJOR_ID=$($PSQL "<query_here>")' # Here's an example of how to query the database
MAJOR_ID=$($PSQL "SELECT major_id FROM majors WHERE major='$MAJOR'") # set the MAJOR_ID variable to a query that gets the new major_id from the database.
'echo $($PSQL "TRUNCATE students, majors, courses, majors_courses")' #instead of manually TRUNCATING(deleteing) each time I want to test the script, add this to the top
INSERT_STUDENT_RESULT=$($PSQL "INSERT INTO students(first_name, last_name, major_id, gpa) VALUES('$FIRST', '$LAST', $MAJOR_ID, $GPA)") #will go through students.csv and insert all values
'pg_dump --clean --create --inserts --username=freecodecamp students > students.sql' #get the sql file 

Start : 22March2025 - Build a Student Database: Part 2 =======================================================================================================================================
https://www.freecodecamp.org/learn/relational-database/learn-sql-by-building-a-student-database-part-2/build-a-student-database-part-2
'psql --username=freecodecamp --dbname=postgres' #login credentials
'psql -U postgres < students.sql' #split the terminal, and import the old DB from the last lesson, created from the dump command
'student_info.sh' #create a new bash script 
'echo -e "\n~~ My Computer Science Students ~~\n"' #use '-e' flag to add escape characters
'PSQL="psql -X --username=freecodecamp --dbname=students --no-align --tuples-only -c"' #how to query in a bashscript to the postgreSQL DB
'SELECT first_name FROM students;' #to only query one column instead of '*' all 
'SELECT first_name, last_name, gpa FROM students;' #select multiple columns 
'SELECT first_name, last_name, gpa FROM students WHERE gpa < 2.5;' #Use one of these to view the same columns as before but only rows WHERE gpa < 2.5
  You can return only rows you want by adding WHERE <condition> to your query. A condition can consist of a column, an operator, and a value. 
SQL has the operators '<' less than, '>' greater than, '>='greater than equal to, '=' equal to, '!=' not equal
'SELECT * FROM students WHERE last_name < 'M' AND gpa = 3.9;' #you can use the 'AND' keyword to add 2 'WHERE' constraints
'SELECT * FROM students WHERE last_name < 'M' AND gpa = 3.9 OR gpa < 2.3;' #you can also use the 'OR' keyword
'SELECT * FROM courses WHERE course LIKE '_lgorithms';' #you can use '_' for pattern matching regex, it will only match one character
'SELECT * FROM courses WHERE course LIKE '%lgorithms';' #using '%' will match ALL patterns(like a phrase, or a letter, whatever)
'SELECT * FROM courses WHERE course LIKE 'Web%';' #will match anything with 'Web' and anything following it
'SELECT * FROM courses WHERE course LIKE '% %';' #will find any pattern with a space in the name
'SELECT * FROM courses WHERE course NOT LIKE '% %';' #new keyword 'NOT LIKE' where it will find everything that DOESN'T match the pattern, this finds all without a space
'SELECT * FROM courses WHERE course ILIKE '<pattern>';' #another new keyword 'ILIKE' will ignore capitalization
'SELECT * FROM courses WHERE course NOT ILIKE '%A%';' # combining 'NOT' and 'ILIKE' will find any pattern without an A regardless of capitalize
'SELECT * FROM courses WHERE course NOT ILIKE '<pattern>' AND course LIKE <pattern> ;' #you can actually combine 2 matching patterns for 'NOT LIKE' and 'LIKE' with 'AND' keyword
'SELECT * FROM students WHERE gpa IS NULL;' #searching for 'IS NULL' 
'SELECT * FROM students WHERE gpa IS NOT NULL;' # searching for 'IS NOT NULL' (all caps)
'SELECT * FROM students ORDER BY gpa;' #'ORDER BY' keyword, will order the results by GPA Ascending(smallest at top)
'SELECT * FROM students ORDER BY gpa DESC, first_name;' #will order by gpa 'DESC' descending, any matching columns with same gpa will then be ordered by name 
'SELECT * FROM students ORDER BY gpa DESC, first_name LIMIT 10;' # 'LIMIT' keyword, will only give you 10 results
'SELECT * FROM students WHERE gpa IS NOT NULL ORDER BY gpa DESC, first_name LIMIT 10;' #finds all students with a gpa that is 'NOT NULL' and ordered by 'DESC'ending, then first name with 'LIMIT'
'SELECT MIN(gpa) FROM students;' # 'MIN' keyword, will find the smallest gpa that isn't NULL
'SELECT MAX(gpa) FROM students;' # 'MAX' keyword, will find the max gpa
'SELECT SUM(major_id) FROM students;' #sum adds all 'major_id's together from the 'students' tables
'SELECT AVG(major_id) FROM students;' # 'AVG' average keyword 
'SELECT CEIL(AVG(major_id)) FROM students;' #round decimals up or down to the nearest whole number with CEIL and FLOOR Use CEIL to round the average major_id up to the nearest whole number.
'SELECT COUNT(*) FROM majors;' #Another function is COUNT. You can use it like this: COUNT(<column>). It will tell you how many entries are in a table for the column.
'SELECT <column> FROM <table> GROUP BY <column>' # 'GROUP BY' keyword - output same as DISTINCT, but with GROUP BY you can add any of the aggregate functions (MIN, MAX, COUNT, etc) to it
'SELECT major_id FROM students GROUP BY major_id;' # Use this method to view the unique major_id values in the students table again.
'SELECT major_id, MIN(gpa) FROM students GROUP BY major_id;' #finds the lowest gpa for each major_id
'SELECT <column> FROM <table> GROUP BY <column> HAVING <condition>' # 'HAVING' keyword -The condition must be an aggregate function with a test. An example to might be to use HAVING COUNT(*) > 0
'SELECT major_id, MIN(gpa), MAX(gpa) FROM students GROUP BY major_id HAVING MAX(gpa) = 4.0;' #. Use HAVING to only show rows from the last query that have a maximum GPA of 4.0.
'SELECT * FROM students FULL JOIN majors ON students.major_id = majors.major_id;' # 'FULL JOIN' will combine the majors table with the students table and join on the the 'majors_id' column
  The FULL JOIN you used will include all rows from both tables, whether or not they have a row using that foreign key in the other.
'SELECT * FROM students LEFT JOIN majors ON students.major_id = majors.major_id;' #'LEFT JOIN' will join on the 'major_id' for each table
  n the LEFT JOIN you used, the students table was the left table since it was on the left side of the JOIN. majors was the right table.
  A LEFT JOIN gets all rows from the left table, but only rows from the right table that are linked to from the left one. 
  Looking at the data, you can see that every student was returned, but the majors without any students were not
'SELECT * FROM students RIGHT JOIN majors ON students.major_id = majors.major_id;' #'RIGHT JOIN' 
  The right join showed all the rows from the right table (majors), but only rows from the left table (students) if they have a major. 
'SELECT * FROM students INNER JOIN majors ON students.major_id = majors.major_id;' #'INNER JOIN' The INNER JOIN only returned students if they have a major and majors that have a student. 
  In other words, it only returned rows if they have a value in the foreign key column (major_id) of the opposite table.
'SELECT * FROM majors INNER JOIN students ON majors.major_id = students.major_id;' #show only students that are enrolled in a major, and only majors that have a student enrolled in it.
'SELECT * FROM majors RIGHT JOIN students ON majors.major_id = students.major_id;' #'RIGHT JOIN' will show ALL students, since they are on the right side of the join
'SELECT * FROM majors FULL JOIN students ON majors.major_id = students.major_id;' #'FULL JOIN' show all rows in both tables whether they have a value in the foreign key column or not
'SELECT DISTINCT(major) FROM students INNER JOIN majors ON students.major_id = majors.major_id;' #'DISTINCT' Keyword = no duplicates
'SELECT * FROM students RIGHT JOIN majors ON students.major_id = majors.major_id WHERE student_id IS NULL;' #show majors where they don't have any students
'SELECT * FROM students LEFT JOIN majors ON students.major_id = majors.major_id WHERE major='Data Science' OR gpa >= 3.8;' #'LEFT JOIN' with multiple 'WHERE' conditions 'OR'
'SELECT students.major_id FROM students FULL JOIN majors AS m ON students.major_id = m.major_id;' # 'AS' keyword, allows you to alias(rename) things
'SELECT s.major_id FROM students AS s FULL JOIN majors AS m ON s.major_id = m.major_id;' # 2 'AS' renames with a 'FULL JOIN'
'SELECT * FROM <table_1> FULL JOIN <table_2> USING(<column>) FULL JOIN <table_3> USING(<column>)' #  You can add a third table to a join like this:
'SELECT * FROM students FULL JOIN majors USING(major_id) FULL JOIN majors_courses USING(major_id);' # 2 'FULL JOIN's (3 tables)? What do I bring to the table? I am the table. 3 tables.
'SELECT COUNT(course), COURSE FROM students INNER JOIN majors USING(major_id) INNER JOIN majors_courses USING(major_id) INNER JOIN courses USING(course_id) GROUP BY course;' # 3 'INNER JOIN'

Start : 24March2025 - World Cup Database ========================================================================================================================================================
https://www.freecodecamp.org/learn/relational-database/build-a-world-cup-database-project/build-a-world-cup-database
Clicking the "hamburger" menu near the top left of the VSCode window,
Going to the "View" menu,
Clicking on the "Command Palette" option,
and running the "CodeRoad: Start" command
'psql --username=freecodecamp --dbname=postgres' #login credentials
InstructSeans :
You should create a database named worldcup
  CREATE DATABASE worldcup;
You should connect to your worldcup database and then create teams and games tables
     \c worldcup;
Your teams table should have a team_id column that is a type of SERIAL and is the primary key, and a name column that has to be UNIQUE
   CREATE TABLE teams (
       team_id SERIAL PRIMARY KEY,
       name VARCHAR(255) UNIQUE NOT NULL
   );
Your games table should have a game_id column that is a type of SERIAL and is the primary key, a year column of type INT, and a round column of type VARCHAR
Your games table should have winner_id and opponent_id foreign key columns that each reference team_id from the teams table
Your games table should have winner_goals and opponent_goals columns that are type INT
All of your columns should have the NOT NULL constraint
   CREATE TABLE games (
       game_id SERIAL PRIMARY KEY,
       year INT NOT NULL,
       round VARCHAR(255) NOT NULL,
       winner_id INT NOT NULL REFERENCES teams(team_id),
       opponent_id INT NOT NULL REFERENCES teams(team_id),
       winner_goals INT NOT NULL,
       opponent_goals INT NOT NULL
   );
Your two script (.sh) files should have executable permissions. Other tests involving these two files will fail until permissions are correct. 
  When these permissions are enabled, the tests will take significantly longer to run
    'chmod +x insert_data.sh'
    'chmod +x queries.sh'
When you run your insert_data.sh script, it should add each unique team to the teams table. There should be 24 rows
When you run your insert_data.sh script, it should insert a row for each line in the games.csv file (other than the top line of the file).
  There should be 32 rows. Each row should have every column filled in with the appropriate info. Make sure to add the correct ID's from the teams table (you cannot hard-code the values)
    #!/bin/bash
    # Do not change code above this line
    # This script should only be run AFTER the database and tables are created
    PSQL="psql --username=freecodecamp --dbname=worldcup -t --no-align -c"
    # Empty the tables
    echo $($PSQL "TRUNCATE TABLE games, teams")
    # Read from games.csv and insert data
    cat games.csv | while IFS="," read YEAR ROUND WINNER OPPONENT WINNER_GOALS OPPONENT_GOALS
    do
      # Skip the header row
      if [[ $YEAR != "year" ]]
      then
        # Insert teams if they don't exist
        # Insert winner
        WINNER_ID=$($PSQL "SELECT team_id FROM teams WHERE name='$WINNER'")
        if [[ -z $WINNER_ID ]]
        then
          INSERT_WINNER_RESULT=$($PSQL "INSERT INTO teams(name) VALUES('$WINNER')")
          if [[ $INSERT_WINNER_RESULT == "INSERT 0 1" ]]
          then
            echo Inserted into teams, $WINNER
          fi
          WINNER_ID=$($PSQL "SELECT team_id FROM teams WHERE name='$WINNER'")
        fi
        # Insert opponent
        OPPONENT_ID=$($PSQL "SELECT team_id FROM teams WHERE name='$OPPONENT'")
        if [[ -z $OPPONENT_ID ]]
        then
          INSERT_OPPONENT_RESULT=$($PSQL "INSERT INTO teams(name) VALUES('$OPPONENT')")
          if [[ $INSERT_OPPONENT_RESULT == "INSERT 0 1" ]]
          then
            echo Inserted into teams, $OPPONENT
          fi
          OPPONENT_ID=$($PSQL "SELECT team_id FROM teams WHERE name='$OPPONENT'")
        fi
    
        # Insert game
        INSERT_GAME_RESULT=$($PSQL "INSERT INTO games(year, round, winner_id, opponent_id, winner_goals, opponent_goals) VALUES($YEAR, '$ROUND', $WINNER_ID, $OPPONENT_ID, $WINNER_GOALS, $OPPONENT_GOALS)")
        if [[ $INSERT_GAME_RESULT == "INSERT 0 1" ]]
        then
          echo Inserted into games, $YEAR $ROUND: $WINNER vs $OPPONENT
        fi
      fi
    done
You should correctly complete the queries in the queries.sh file. Fill in each empty echo command to get the output of what is suggested with the command above it. 
  Only use a single line like the first query. The output should match what is in the expected_output.txt file exactly, take note of the number of decimal places in some of the query results
    echo -e "\nTotal number of goals in all games from winning teams:"
    echo "$($PSQL "SELECT SUM(winner_goals) FROM games")"
    echo -e "\nTotal number of goals in all games from both teams combined:"
    echo "$($PSQL "SELECT SUM(winner_goals + opponent_goals) FROM games")"
    echo -e "\nAverage number of goals in all games from the winning teams:"
    echo "$($PSQL "SELECT AVG(winner_goals) FROM games")"
    echo -e "\nAverage number of goals in all games from the winning teams rounded to two decimal places:"
    echo "$($PSQL "SELECT ROUND(AVG(winner_goals), 2) FROM games")"
    echo -e "\nAverage number of goals in all games from both teams:"
    echo "$($PSQL "SELECT AVG(winner_goals + opponent_goals) FROM games")"
    echo -e "\nMost goals scored in a single game by one team:"
    echo "$($PSQL "SELECT MAX(GREATEST(winner_goals, opponent_goals)) FROM games")"
    echo -e "\nNumber of games where the winning team scored more than two goals:"
    echo "$($PSQL "SELECT COUNT(*) FROM games WHERE winner_goals > 2")"
    echo -e "\nWinner of the 2018 tournament team name:"
    echo "$($PSQL "SELECT name FROM teams INNER JOIN games ON teams.team_id = games.winner_id WHERE year = 2018 AND round = 'Final'")"
    echo -e "\nList of teams who played in the 2014 'Eighth-Final' round:"
    echo "$($PSQL "SELECT DISTINCT name FROM teams INNER JOIN games ON teams.team_id = games.winner_id OR teams.team_id = games.opponent_id WHERE year = 2014 AND round = 'Eighth-Final' ORDER BY name")"
    echo -e "\nList of unique winning team names in the whole data set:"
    echo "$($PSQL "SELECT DISTINCT name FROM teams INNER JOIN games ON teams.team_id = games.winner_id ORDER BY name")"
    echo -e "\nYear and team name of all the champions:"
    echo "$($PSQL "SELECT year, name FROM teams INNER JOIN games ON teams.team_id = games.winner_id WHERE round = 'Final' ORDER BY year")"
    echo -e "\nList of teams that start with 'Co':"
    echo "$($PSQL "SELECT name FROM teams WHERE name LIKE 'Co%' ORDER BY name")"
'pg_dump -cC --inserts -U freecodecamp worldcup > worldcup.sql' #dump the sql file

Start : 26March2025 - Learn Advanced Bash by Building a Kitty Ipsum Translator ================================================================================================================
Clicking the "hamburger" menu near the top left of the VSCode window,
Going to the "View" menu,
Clicking on the "Command Palette" option,
and running the "CodeRoad: Start" command
'<command> > <filename>' #how to add to a file, with '>' will take the output from a command and send it to a file, if no file exists, it will create it
'echo hello bash > stdout.txt' # will create a new file if none existed, be careful because this will overwrite everything in that file, 'echo' will not be put in the file
'<command> >> <filename>' # '>>' to APPEND to a file, will add it to the end if a file exists and not overwrite
'> stdout.txt' #to redirect nothing into the file, which will empty it
There’s two types of output, 'stdout' (standard out) for when a command is successful, and 'stderr' (standard error) for when it’s not. 
If you give a bad command to be output to a file, it will not run or be added to the file
'bad_command 2> stderr.txt' #You can redirect stderr with '2>'. Enter the same bad command but redirect stderr to stderr.txt 'bash: bad_command: command not found'
'echo hello bash 1> stdout.txt' #Similarily, you can use '1>' to redirect stdout
'stdin' = stdout and stderr are for output. 'stdin' (standard in) is the third thing commands can use and is for getting input. The default is the keyboard
'command> < <filename_for_stdin>' #Just like you can redirect output, you can redirect stdin as well. Here's an example with '<'
'read NAME < name.txt' #Use the read command to assign the NAME variable to the contents of name.txt by redirecting the stdin. - the '$NAME' variable will be changed to the text in 'name.txt'
'<command_1> | <command_2>' #'|' = pipe command, It will use the output from one command as input for another. This will take the stdout from command_1 and use it as the stdin for command_2
'echo Sean | read NAME' # will take 'Sean' and add it to the variable of '$NAME', this command will be run as a subprocess, and will not save to the your current terminal variable of '$NAME'
'cat name.txt' #reads the name.txt file in the terminal
'echo Sean | ./script.sh 2> stderr.txt' #will use 'Sean' for an input into './script.sh' and any error will be sent to 'stderr.txt' with '2>'
'echo Sean | ./script.sh 2> stderr.txt > stdout.txt' #will input 'Sean' into script and redirect both errors and output to different text files, pretty cool
'./script.sh < name.txt 2> stderr.txt > stdout.txt' #will use the 'name.txt' as input and send the errors to 'stderr.txt' and the output to 'stdout.txt' - input, output and error in 1 line
'wc' = Word Count, new keyword gives info about the file... like how many words, and bytes, lines 'wc -l' = lines, to display how many lines 'wc -w' for how many words, '-m', '-c' characters
'cat kitty_ipsum_1.txt | wc' #will pipe the contents of 'kitty_ipsum_1.txt' into 'wc' wordcount to get more info on the file
'wc < kitty_ipsum_1.txt' #using input instead of output for above command
'grep 'meow' kitty_ipsum_1.txt' #will show all the lines with 'meow' in them, not just words
'grep --color 'meow' kitty_ipsum_1.txt' #will add color to the returned results 'meow' now in red
'grep --color -n 'meow' kitty_ipsum_1.txt' # '-n' flag for 'numbers' will add line numbers for each line with 'meow' and color
'grep --color -n 'meow[a-z]*' kitty_ipsum_1.txt' # shows all the words that start with 'meow' using a regular expression 'meow[a-z]*' 
'grep -c 'meow[a-z]*' kitty_ipsum_1.txt' # '-c' flag for count, will show how many times it appears
'sed 's/<pattern_to_replace>/<text_to_replace_it_with>/' <filename>' #'sed' = 'stream editor' is used to replace words/patterns in a file
'sed 's/r/2/' name.tx' #this will replace 'r' with '2' 
'sed 's/freecodecamp/f233C0d3C@mp/i' name.txt' #'i' flag, notice how it's after the '/i' instead of '-i', this is the 'ignore' flag and will ignore case for matching(like capitalized)
  '/g' flag is global, and would do the same thing
'./translate.sh kitty_ipsum_1.txt' #use a txt file as an input argument for a script, without '<' or piping
'diff kitty_ipsum_1.txt doggy_ipsum_1.txt' # 'diff' keyword/command, will compare 2 files and show you which lines they are different, line by line
'diff --color kitty_ipsum_1.txt doggy_ipsum_1.txt'  #add color to the different lines
'./translate.sh kitty_ipsum_2.txt > doggy_ipsum_2.txt' # take a txt file as input and run it through a script and put output into a new textfile












































